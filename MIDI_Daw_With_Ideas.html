<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upgraded MIDI DAW</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            background: #18181b; /* zinc-900 */
            color: #e4e4e7; /* zinc-200 */
        }
        .piano-key {
            stroke: #3f3f46; /* zinc-700 */
            stroke-width: 1;
        }
        .piano-key.white { fill: #f4f4f5; } /* zinc-100 */
        .piano-key.black { fill: #27272a; } /* zinc-800 */
        .piano-key:hover {
            fill: #60a5fa; /* blue-400 */
        }
        .note {
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.7);
            position: absolute;
            box-sizing: border-box;
            min-width: 4px;
            /* background-color is set dynamically */
        }
        .piano-label {
            font-size: 10px;
            fill: #a1a1aa; /* zinc-400 */
            text-anchor: end;
            alignment-baseline: middle;
            pointer-events: none;
        }
        .top-bar {
            background: #27272a; /* zinc-800 */
            border-bottom: 1px solid #3f3f46; /* zinc-700 */
            position: relative;
            z-index: 40;
            display: flex;
            align-items: center;
            padding: 0 16px;
            height: 50px;
            flex-shrink: 0;
        }
        #timeline-header {
            background: #27272a; /* zinc-800 */
            border-bottom: 1px solid #3f3f46; /* zinc-700 */
            position: relative;
            z-index: 30; /* Increased from 20 */
            height: 30px;
            overflow: hidden;
            flex-shrink: 0;
        }
        #measures-container {
            display: flex;
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
        }
        .measure-marker {
            font-size: 12px;
            color: #a1a1aa; /* zinc-400 */
            border-left: 1px solid #52525b; /* zinc-600 */
            box-sizing: border-box;
            display: flex;
            align-items: center;
            padding-left: 4px;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            padding: 0 12px;
            border-left: 1px solid #3f3f46; /* zinc-700 */
            height: 100%;
        }
        .transport-btn, #toolbar button {
            background: transparent;
            border: none;
            color: #e4e4e7;
            border-radius: 6px;
            padding: 8px;
            margin: 0 2px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }
        .transport-btn:hover, #toolbar button:hover {
            background: #3f3f46; /* zinc-700 */
        }
        #toolbar button[data-active='true'] {
             background-color: #3b82f6; /* blue-500 */
             color: white;
        }
        .transport-btn.active {
            color: #3b82f6;
        }
        .transport-btn svg, #toolbar svg {
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        select, input[type="number"], input[type="range"] {
            background: #3f3f46 !important; /* zinc-700 */
            color: #e4e4e7 !important; /* zinc-200 */
            border-color: #52525b !important; /* zinc-600 */
            border-radius: 4px;
        }
        input[type="number"] {
            padding: 4px 8px;
        }
        #grid-container {
            overflow: auto;
        }
        #playback-cursor {
            position:absolute;
            top:0;
            left:0;
            width:2px;
            height:100%;
            background:#facc15; /* yellow-400 */
            z-index:25;
            pointer-events: none;
            display:none;
        }
        .snap-indicator {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #f59e0b; /* amber-500 */
            opacity: 0.7;
            pointer-events: none;
            z-index:15;
            display: none;
        }
        .time-subdivisions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .subdivision-btn {
            background: #3f3f46;
            color: #e4e4e7;
            border: 1px solid #52525b;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .subdivision-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        .subdivision-btn:hover {
            background: #52525b;
        }
        .subdivision-btn.active:hover {
            background: #2563eb;
        }
        .grid-line-major { background: #52525b !important; } /* zinc-600 */
        .grid-line-beat { background: #3f3f46 !important; } /* zinc-700 */
        .grid-line-subdivision { background: #27272a !important; } /* zinc-800 */
        .note.preview {
            opacity: 0.5;
            border: 2px dashed #60a5fa;
            background: transparent !important;
        }
        .timeline-tick {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 1px solid;
            display: flex;
            align-items: center;
            font-size: 10px;
            color: #a1a1aa;
            padding-left: 2px;
            box-sizing: border-box;
            white-space: nowrap;
            z-index: 35; /* Added z-index */
        }
        .timeline-tick.measure {
            border-color: #52525b; /* zinc-600 */
            font-weight: 600;
            font-size: 12px;
            z-index: 40; /* Higher z-index for measures */
        }
        .timeline-tick.beat {
            border-color: #3f3f46; /* zinc-700 */
            z-index: 37; /* Medium z-index for beats */
        }
        .timeline-tick.subdivision {
            border-color: #27272a; /* zinc-800 */
            font-size: 9px;
            opacity: 0.7;
            z-index: 35; /* Base z-index for subdivisions */
        }
        .playback-position {
            background: #27272a;
            border: 1px solid #3f3f46;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            min-width: 80px;
            text-align: center;
        }
        .loop-region {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(34, 197, 94, 0.2); /* green-500 with opacity */
            border: 1px solid #22c55e;
            border-radius: 2px;
            z-index: 5;
            pointer-events: none;
        }
        .loop-marker {
            position: absolute;
            top: 0;
            width: 8px;
            height: 100%;
            background: #22c55e;
            cursor: col-resize;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .loop-marker.start {
            border-radius: 2px 0 0 2px;
        }
        .loop-marker.end {
            border-radius: 0 2px 2px 0;
            margin-left: -8px;
        }
        .loop-region:hover .loop-marker {
            opacity: 1;
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden">

    <div class="top-bar">
        <h1 class="text-xl font-bold text-white mr-4">JS MIDI DAW</h1>
        
        <div class="control-group">
            <label for="upload" class="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow transition-colors text-sm">
                Upload MIDI
            </label>
            <input type="file" id="upload" accept=".mid,.midi" class="hidden">
            <button id="export" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md shadow transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed text-sm" disabled>Export MIDI</button>
        </div>

        <div class="control-group">
            <button id="rewind-btn" class="transport-btn" title="Rewind to Start">
                <svg fill="currentColor" viewBox="0 0 20 20"><path d="M8.445 14.832A1 1 0 0010 14.032V5.968a1 1 0 00-1.555-.832L4 9.168V6a1 1 0 00-2 0v8a1 1 0 102 0v-3.168l4.445 4zM15.555 14.832A1 1 0 0017 14.032V5.968a1 1 0 00-1.555-.832L11 9.168V6a1 1 0 10-2 0v8a1 1 0 102 0v-3.168l4.555 4z"/></svg>
            </button>
            <button id="play-btn" class="transport-btn" title="Play">
                <svg id="play-icon" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/></svg>
                <svg id="pause-icon" class="hidden" viewBox="0 0 20 20" fill="currentColor"><path d="M5.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75A.75.75 0 007.25 3h-1.5zM12.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75a.75.75 0 00-.75-.75h-1.5z"/></svg>
            </button>
            <button id="stop-btn" class="transport-btn" title="Stop">
                <svg viewBox="0 0 20 20" fill="currentColor"><path d="M5 3.75A1.75 1.75 0 016.75 2h6.5A1.75 1.75 0 0115 3.75v12.5A1.75 1.75 0 0113.25 18h-6.5A1.75 1.75 0 015 16.25V3.75z"/></svg>
            </button>
            <button id="loop-btn" class="transport-btn" title="Toggle Loop">
                <svg viewBox="0 0 20 20" fill="currentColor"><path d="M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm-11.90-5.126a.75.75 0 00.42.404 7 7 0 0011.712-3.138.75.75 0 00-1.449-.39 5.5 5.5 0 01-9.201 2.466l-.312-.311v-2.43a.75.75 0 00-1.5 0v4.242c0 .414.336.75.75.75h4.243a.75.75 0 000-1.5H6.1l.31-.31z"/></svg>
            </button>
            <div class="playback-position" id="playback-position">0:00:000</div>
        </div>
        
        <div class="control-group">
            <label for="signature-select" class="text-sm mr-2">Signature:</label>
            <select id="signature-select" class="text-sm rounded-md p-1">
                <option value="4/4">4/4</option>
                <option value="3/4">3/4</option>
                <option value="6/8">6/8</option>
                <option value="5/4">5/4</option>
            </select>
            <label for="tempo-input" class="text-sm ml-4 mr-2">Tempo:</label>
            <input type="number" id="tempo-input" min="20" max="300" value="120" class="w-16 text-sm">
        </div>

        <div class="control-group">
            <label class="text-sm mr-2">Snap:</label>
            <div class="time-subdivisions">
                <button class="subdivision-btn" data-subdivision="1">1/1</button>
                <button class="subdivision-btn" data-subdivision="2">1/2</button>
                <button class="subdivision-btn active" data-subdivision="4">1/4</button>
                <button class="subdivision-btn" data-subdivision="8">1/8</button>
                <button class="subdivision-btn" data-subdivision="16">1/16</button>
                <button class="subdivision-btn" data-subdivision="32">1/32</button>
            </div>
            <label class="text-sm ml-4 mr-2">
                <input type="checkbox" id="snap-enabled" checked class="mr-1">
                Snap to Grid
            </label>
        </div>

        <div class="control-group">
            <label for="zoom-range" class="text-sm mr-2">Zoom:</label>
            <input type="range" id="zoom-range" min="20" max="500" value="100" class="w-24">
        </div>
    </div>
    
    <div id="toolbar" class="flex items-center h-10 bg-zinc-800/80 backdrop-blur-sm border-b border-zinc-700 px-2 space-x-1 shrink-0">
        <button id="tool-select" title="Select Tool (V)">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M2 3L8 21L11 14L18 11L2 3Z"/>
            </svg>
        </button>
        <button id="tool-pencil" title="Pencil Tool (B)">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.731 2.269a2.625 2.625 0 0 0-3.712 0l-1.157 1.157 3.712 3.712 1.157-1.157a2.625 2.625 0 0 0 0-3.712ZM19.513 8.199l-3.712-3.712-8.4 8.4a5.25 5.25 0 0 0-1.32 2.214l-.8 2.685a.75.75 0 0 0 .933.933l2.685-.8a5.25 5.25 0 0 0 2.214-1.32l8.4-8.4Z" /> <path d="M5.25 5.25a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3V13.5a.75.75 0 0 0-1.5 0v5.25a1.5 1.5 0 0 1-1.5 1.5H5.25a1.5 1.5 0 0 1-1.5-1.5V8.25a1.5 1.5 0 0 1 1.5-1.5h5.25a.75.75 0 0 0 0-1.5H5.25Z" /></svg>
        </button>
        <button id="tool-cutter" title="Cutter Tool (C)">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M9.64 7.64L11 9L13 7L22 16V22H16L7 13L9.64 7.64Z"/>
                <path d="M7 2L2 7L7 12L12 7L7 2ZM7 7.5C6.72 7.5 6.5 7.28 6.5 7S6.72 6.5 7 6.5 7.5 6.72 7.5 7 7.28 7.5 7 7.5Z"/>
            </svg>
        </button>
    </div>

    <div id="timeline-header">
        <div id="timeline-container" class="relative w-full h-full" style="z-index: 35;"></div>
    </div>

    <main id="main-content" class="flex-grow flex overflow-hidden">
        <div id="piano-roll-view" class="flex w-full h-full">
            <div id="piano-keys" class="bg-zinc-800 h-full flex-shrink-0 z-30" style="width: 80px;">
                <svg id="piano-keys-svg" width="80" class="h-full"></svg>
            </div>
            <div id="grid-container" class="flex-grow h-full overflow-auto bg-zinc-900 relative">
                <div id="grid-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-0"></div>
                <div id="note-container" class="relative z-10 h-full"></div>
                <div id="playback-cursor"></div>
                <div id="snap-indicator" class="snap-indicator"></div>
                <div id="loop-region" class="loop-region" style="display: none;">
                    <div class="loop-marker start" id="loop-start-marker"></div>
                    <div class="loop-marker end" id="loop-end-marker"></div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- Tone.js Start Context ---
        document.documentElement.addEventListener('mousedown', async () => {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log('Audio context started');
            }
        });

        // --- DOM Elements ---
        const uploadInput = document.getElementById('upload');
        const exportButton = document.getElementById('export');
        
        const pianoKeysSVG = document.getElementById('piano-keys-svg');
        const gridContainer = document.getElementById('grid-container');
        const gridLinesContainer = document.getElementById('grid-lines-container');
        const noteContainer = document.getElementById('note-container');
        const playbackCursor = document.getElementById('playback-cursor');

        const timelineHeader = document.getElementById('timeline-header');
        const measuresContainer = document.getElementById('measures-container');
        const tempoInput = document.getElementById('tempo-input');
        
        const playBtn = document.getElementById('play-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const stopBtn = document.getElementById('stop-btn');
        const rewindBtn = document.getElementById('rewind-btn');
        const zoomRange = document.getElementById('zoom-range');
        const signatureSelect = document.getElementById('signature-select');
        const toolbar = document.getElementById('toolbar');
        const snapEnabledCheckbox = document.getElementById('snap-enabled');
        const snapIndicator = document.getElementById('snap-indicator');
        const timelineContainer = document.getElementById('timeline-container');
        const playbackPosition = document.getElementById('playback-position');
        const loopBtn = document.getElementById('loop-btn');
        const loopRegion = document.getElementById('loop-region');
        const loopStartMarker = document.getElementById('loop-start-marker');
        const loopEndMarker = document.getElementById('loop-end-marker');

        // --- State ---
        let midiData = null;
        let zoom = 100; // Represents pixels per second
        let parts = [];
        let synths = [];
        let activeTool = 'select';
        let currentSubdivision = 4; // 1/4 notes by default
        let snapToGrid = true;
        let isDrawing = false;
        let previewNote = null;
        let isLooping = false;
        let loopStart = 0;
        let loopEnd = 8; // Default 2 measures in 4/4
        let maxMeasures = 1000; // Practically unlimited
        let playbackUpdateInterval = null;

        // --- Instruments ---
        let sampler = new Tone.Sampler().toDestination();
        let samplesLoaded = false;
        const trackColors = ['#3b82f6','#22c55e','#ef4444','#eab308','#a855f7','#f97316','#ec4899','#6366f1'];

        // --- Constants ---
        const NOTE_HEIGHT = 16;
        const MIDI_NOTE_RANGE = { min: 21, max: 108 };

        // --- Initialization ---
        window.onload = () => {
            setupPianoKeys();
            setupToolbar();
            setupSubdivisionControls();
            setupGridInteraction();
            draw();
            Tone.Transport.bpm.value = parseInt(tempoInput.value, 10);
            const sig = signatureSelect.value.split('/').map(n => parseInt(n));
            Tone.Transport.timeSignature = sig;
        };

        // --- Event Listeners ---
        uploadInput.addEventListener('change', handleFileUpload);
        exportButton.addEventListener('click', handleExport);
        tempoInput.addEventListener('change', (e) => {
            const tempo = parseInt(e.target.value, 10) || 120;
            Tone.Transport.bpm.value = tempo;
            draw();
        });
        signatureSelect.addEventListener('change', (e) => {
            const sig = e.target.value.split('/').map(n => parseInt(n));
            Tone.Transport.timeSignature = sig;
            draw();
        });
        zoomRange.addEventListener('input', (e) => {
            zoom = parseInt(e.target.value, 10);
            draw();
        });
        gridContainer.addEventListener('scroll', () => {
            pianoKeysSVG.style.marginTop = `-${gridContainer.scrollTop}px`;
            timelineHeader.scrollLeft = gridContainer.scrollLeft;
        });

        playBtn.addEventListener('click', handlePlayPause);
        stopBtn.addEventListener('click', handleStop);
        rewindBtn.addEventListener('click', handleRewind);
        snapEnabledCheckbox.addEventListener('change', (e) => {
            snapToGrid = e.target.checked;
        });
        loopBtn.addEventListener('click', toggleLoop);
        
        // Timeline click to set playback position
        timelineContainer.addEventListener('click', (e) => {
            const rect = timelineContainer.getBoundingClientRect();
            const x = e.clientX - rect.left + timelineHeader.scrollLeft;
            const time = x / zoom;
            setPlaybackPosition(time);
        });

        // --- Playback Position Management ---
        function setPlaybackPosition(time) {
            Tone.Transport.seconds = Math.max(0, time);
            updatePlaybackDisplay();
        }

        function updatePlaybackDisplay() {
            const currentTime = Tone.Transport.seconds;
            const beatsPerMeasure = Tone.Transport.timeSignature[0];
            const secondsPerBeat = 60 / Tone.Transport.bpm.value;
            
            const totalBeats = currentTime / secondsPerBeat;
            const measure = Math.floor(totalBeats / beatsPerMeasure) + 1;
            const beat = Math.floor(totalBeats % beatsPerMeasure) + 1;
            const subdivision = Math.floor((totalBeats % 1) * (currentSubdivision / 4));
            const tick = Math.floor(((totalBeats % 1) * (currentSubdivision / 4) % 1) * 1000);
            
            playbackPosition.textContent = `${measure}:${beat}:${subdivision.toString().padStart(2, '0')}:${tick.toString().padStart(3, '0')}`;
        }

        function toggleLoop() {
            isLooping = !isLooping;
            loopBtn.classList.toggle('active', isLooping);
            loopRegion.style.display = isLooping ? 'block' : 'none';
            
            if (isLooping) {
                Tone.Transport.loop = true;
                Tone.Transport.loopStart = loopStart;
                Tone.Transport.loopEnd = loopEnd;
                updateLoopRegionDisplay();
            } else {
                Tone.Transport.loop = false;
            }
        }

        function updateLoopRegionDisplay() {
            const startX = loopStart * zoom;
            const endX = loopEnd * zoom;
            const width = endX - startX;
            
            loopRegion.style.left = `${startX}px`;
            loopRegion.style.width = `${width}px`;
        }

        // --- File & MIDI Handling ---
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            try {
                const arrayBuffer = await file.arrayBuffer();
                midiData = new Midi(arrayBuffer);
                exportButton.disabled = false;
                
                if (midiData.header.tempos.length > 0) {
                    const tempo = Math.round(midiData.header.tempos[0].bpm);
                    tempoInput.value = tempo;
                    Tone.Transport.bpm.value = tempo;
                }
                if (midiData.header.timeSignatures.length > 0) {
                    const sig = midiData.header.timeSignatures[0].timeSignature;
                    const sigString = `${sig[0]}/${sig[1]}`;
                    if ([...signatureSelect.options].some(o => o.value === sigString)) {
                        signatureSelect.value = sigString;
                        Tone.Transport.timeSignature = sig;
                    }
                }
                draw();
            } catch (error) {
                console.error("Error parsing MIDI file:", error);
                alert("Could not parse the MIDI file.");
            }
        }

        function handleExport() {
            if (!midiData) return;
            try {
                const midiArray = midiData.toArray();
                const blob = new Blob([midiArray], { type: "audio/midi" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `${midiData.name || 'exported_midi'}.mid`;
                a.click();
                URL.revokeObjectURL(a.href);
            } catch (error) {
                console.error("Error exporting MIDI file:", error);
            }
        }
        
        // --- Time Management Functions ---
        function setupSubdivisionControls() {
            const subdivisionBtns = document.querySelectorAll('.subdivision-btn');
            subdivisionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    subdivisionBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSubdivision = parseInt(btn.dataset.subdivision);
                    draw();
                });
            });
        }

        function getTimeForPosition(x) {
            const rawTime = x / zoom;
            if (!snapToGrid) return rawTime;
            
            const secondsPerBeat = 60 / Tone.Transport.bpm.value;
            const secondsPerSubdivision = secondsPerBeat / (currentSubdivision / 4);
            return Math.round(rawTime / secondsPerSubdivision) * secondsPerSubdivision;
        }

        function getPositionForTime(time) {
            return time * zoom;
        }

        function getQuantizedDuration(duration) {
            if (!snapToGrid) return Math.max(duration, 0.1);
            
            const secondsPerBeat = 60 / Tone.Transport.bpm.value;
            const minDuration = secondsPerBeat / (currentSubdivision / 4);
            const quantizedDuration = Math.max(Math.round(duration / minDuration) * minDuration, minDuration);
            return quantizedDuration;
        }

        function getNoteFromY(y) {
            const noteIndex = Math.floor(y / NOTE_HEIGHT);
            return MIDI_NOTE_RANGE.max - noteIndex;
        }

        function getYFromNote(midi) {
            const noteIndex = MIDI_NOTE_RANGE.max - midi;
            return noteIndex * NOTE_HEIGHT;
        }

        // --- Grid Interaction ---
        function setupGridInteraction() {
            let startX, startNote, originalX;
            
            gridContainer.addEventListener('mousedown', (e) => {
                if (activeTool === 'pencil') {
                    handlePencilDown(e);
                }
            });

            gridContainer.addEventListener('mousemove', (e) => {
                if (activeTool === 'pencil') {
                    handlePencilMove(e);
                }
                
                if (snapToGrid) {
                    updateSnapIndicator(e);
                }
            });

            gridContainer.addEventListener('mouseup', (e) => {
                if (activeTool === 'pencil') {
                    handlePencilUp(e);
                }
            });

            gridContainer.addEventListener('mouseleave', () => {
                hideSnapIndicator();
                if (previewNote) {
                    previewNote.remove();
                    previewNote = null;
                }
            });
        }

        function handlePencilDown(e) {
            const rect = gridContainer.getBoundingClientRect();
            const x = e.clientX - rect.left + gridContainer.scrollLeft;
            const y = e.clientY - rect.top + gridContainer.scrollTop;
            
            const time = getTimeForPosition(x);
            const midi = getNoteFromY(y);
            
            if (midi < MIDI_NOTE_RANGE.min || midi > MIDI_NOTE_RANGE.max) return;
            
            isDrawing = true;
            startX = x;
            startNote = { time, midi };
            
            createPreviewNote(time, midi, 0.25); // Default quarter note duration
            e.preventDefault();
        }

        function handlePencilMove(e) {
            if (!isDrawing || !startNote) return;
            
            const rect = gridContainer.getBoundingClientRect();
            const currentX = e.clientX - rect.left + gridContainer.scrollLeft;
            const duration = Math.max(getTimeForPosition(currentX) - startNote.time, 0.1);
            const quantizedDuration = getQuantizedDuration(duration);
            
            if (previewNote) {
                previewNote.style.width = `${quantizedDuration * zoom}px`;
            }
        }

        function handlePencilUp(e) {
            if (!isDrawing || !startNote) return;
            
            const rect = gridContainer.getBoundingClientRect();
            const endX = e.clientX - rect.left + gridContainer.scrollLeft;
            const duration = Math.max(getTimeForPosition(endX) - startNote.time, 0.1);
            const quantizedDuration = getQuantizedDuration(duration);
            
            // Add note to MIDI data
            addNoteToMidiData(startNote.time, startNote.midi, quantizedDuration, 0.8);
            
            // Clean up
            if (previewNote) {
                previewNote.remove();
                previewNote = null;
            }
            
            isDrawing = false;
            startNote = null;
            
            // Redraw to show the actual note
            drawPianoRoll();
        }

        function createPreviewNote(time, midi, duration) {
            if (previewNote) {
                previewNote.remove();
            }
            
            const noteDiv = document.createElement('div');
            noteDiv.classList.add('note', 'preview');
            
            const y = getYFromNote(midi);
            const x = getPositionForTime(time);
            const width = duration * zoom;
            
            noteDiv.style.top = `${y}px`;
            noteDiv.style.left = `${x}px`;
            noteDiv.style.width = `${width}px`;
            noteDiv.style.height = `${NOTE_HEIGHT - 2}px`;
            
            noteContainer.appendChild(noteDiv);
            previewNote = noteDiv;
        }

        function updateSnapIndicator(e) {
            const rect = gridContainer.getBoundingClientRect();
            const x = e.clientX - rect.left + gridContainer.scrollLeft;
            const snappedTime = getTimeForPosition(x);
            const snappedX = getPositionForTime(snappedTime);
            
            snapIndicator.style.left = `${snappedX}px`;
            snapIndicator.style.display = 'block';
        }

        function hideSnapIndicator() {
            snapIndicator.style.display = 'none';
        }

        function addNoteToMidiData(time, midi, duration, velocity = 0.8) {
            if (!midiData) {
                // Create new MIDI data if none exists
                midiData = new Midi();
                midiData.addTrack();
                exportButton.disabled = false;
            }
            
            if (midiData.tracks.length === 0) {
                midiData.addTrack();
            }
            
            // Add to first track for now
            const track = midiData.tracks[0];
            const noteName = Tone.Midi(midi).toNote();
            
            track.addNote({
                name: noteName,
                time: time,
                duration: duration,
                velocity: velocity
            });
            
            console.log(`Added note: ${noteName} at ${time}s for ${duration}s`);
        }

        // --- Drawing and UI ---
        function setupToolbar() {
            const tools = ['select', 'pencil', 'cutter'];
            tools.forEach(tool => {
                const btn = document.getElementById(`tool-${tool}`);
                if(btn) btn.addEventListener('click', () => setActiveTool(tool));
            });
            setActiveTool('select'); // Set default tool
        }

        function setActiveTool(toolName) {
            activeTool = toolName;
            ['select', 'pencil', 'cutter'].forEach(tool => {
                const btn = document.getElementById(`tool-${tool}`);
                if(btn) btn.dataset.active = (tool === toolName);
            });
            gridContainer.style.cursor = toolName === 'pencil' ? 'crosshair' : 'default';
        }

        function draw() {
            if (Tone.Transport.state === 'started') handleStop();
            drawPianoRoll();
            drawTimeline();
            drawGrid();
            updateLoopRegionDisplay();
        }

        function setupPianoKeys() {
            const keys = [];
            for (let midi = MIDI_NOTE_RANGE.max; midi >= MIDI_NOTE_RANGE.min; midi--) {
                const isBlack = [1, 3, 6, 8, 10].includes(midi % 12);
                keys.push({ midi, black: isBlack, name: Tone.Midi(midi).toNote() });
            }

            pianoKeysSVG.innerHTML = '';
            const svgNS = "http://www.w3.org/2000/svg";
            const keyWidth = 80;
            const blackKeyWidth = 50;
            const totalHeight = keys.length * NOTE_HEIGHT;
            
            pianoKeysSVG.setAttribute('viewBox', `0 0 ${keyWidth} ${totalHeight}`);
            pianoKeysSVG.style.height = `${totalHeight}px`;
            noteContainer.style.height = `${totalHeight}px`;
            gridLinesContainer.style.height = `${totalHeight}px`;

            keys.forEach((key, idx) => {
                const y = idx * NOTE_HEIGHT;
                const rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', 0);
                rect.setAttribute('y', y);
                rect.setAttribute('width', key.black ? blackKeyWidth : keyWidth);
                rect.setAttribute('height', NOTE_HEIGHT);
                rect.setAttribute('class', key.black ? 'piano-key black' : 'piano-key white');
                rect.dataset.midi = key.midi;
                pianoKeysSVG.appendChild(rect);

                if (!key.black) {
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', keyWidth - 5);
                    text.setAttribute('y', y + NOTE_HEIGHT / 2);
                    text.setAttribute('class', 'piano-label');
                    text.textContent = key.name;
                    pianoKeysSVG.appendChild(text);
                }
            });
        }
        
        function drawGrid() {
            gridLinesContainer.innerHTML = '';
            const totalDuration = midiData ? Math.max(midiData.duration, 32) : 32; // Minimum 32 seconds
            const containerWidth = totalDuration * zoom;

            // Horizontal lines (piano keys)
            const numKeys = MIDI_NOTE_RANGE.max - MIDI_NOTE_RANGE.min + 1;
            for (let i = 0; i <= numKeys; i++) {
                const line = document.createElement('div');
                const isBlackKey = [1, 3, 6, 8, 10].includes((MIDI_NOTE_RANGE.max - i) % 12);
                line.className = `absolute w-full h-px ${isBlackKey ? 'bg-zinc-700/75' : 'bg-zinc-800'}`;
                line.style.top = `${i * NOTE_HEIGHT - 1}px`;
                line.style.width = `${containerWidth}px`;
                gridLinesContainer.appendChild(line);
            }
            
            // Vertical lines (time grid)
            const beatsPerMeasure = Tone.Transport.timeSignature[0];
            const secondsPerBeat = 60 / Tone.Transport.bpm.value;
            const secondsPerMeasure = secondsPerBeat * beatsPerMeasure;
            const secondsPerSubdivision = secondsPerBeat / (currentSubdivision / 4);
            
            // Calculate how many subdivisions we need
            const totalSubdivisions = Math.ceil(totalDuration / secondsPerSubdivision);
            
            for (let i = 0; i <= totalSubdivisions; i++) {
                const time = i * secondsPerSubdivision;
                const x = time * zoom;
                
                // Determine line type
                const subdivisionInMeasure = i % (beatsPerMeasure * currentSubdivision / 4);
                const subdivisionInBeat = i % (currentSubdivision / 4);
                
                let lineClass;
                if (subdivisionInMeasure === 0) {
                    lineClass = 'grid-line-major'; // Measure lines
                } else if (subdivisionInBeat === 0) {
                    lineClass = 'grid-line-beat'; // Beat lines
                } else {
                    lineClass = 'grid-line-subdivision'; // Subdivision lines
                }
                
                const line = document.createElement('div');
                line.className = `absolute h-full w-px ${lineClass}`;
                line.style.left = `${x}px`;
                gridLinesContainer.appendChild(line);
            }
        }

        function drawPianoRoll() {
            noteContainer.innerHTML = '';
            
            // Add snap indicator back after clearing
            const snapIndicatorElement = document.createElement('div');
            snapIndicatorElement.id = 'snap-indicator';
            snapIndicatorElement.className = 'snap-indicator';
            noteContainer.appendChild(snapIndicatorElement);
            
            if (!midiData) {
                const totalDuration = 32; // Default duration
                const containerWidth = Math.max(totalDuration * zoom, gridContainer.clientWidth);
                noteContainer.style.width = `${containerWidth}px`;
                return;
            }

            const totalDuration = Math.max(midiData.duration, 32);
            const containerWidth = Math.max(totalDuration * zoom, gridContainer.clientWidth);
            noteContainer.style.width = `${containerWidth}px`;

            const midiKeys = Array.from({ length: MIDI_NOTE_RANGE.max - MIDI_NOTE_RANGE.min + 1 }, (_, i) => MIDI_NOTE_RANGE.max - i);

            midiData.tracks.forEach((track, trackIndex) => {
                const color = trackColors[trackIndex % trackColors.length];
                track.notes.forEach(note => {
                    const keyIdx = midiKeys.indexOf(note.midi);
                    if (keyIdx === -1) return;

                    const noteDiv = document.createElement('div');
                    noteDiv.classList.add('note');
                    const y = keyIdx * NOTE_HEIGHT;
                    const x = note.time * zoom;
                    const width = note.duration * zoom;
                    
                    noteDiv.style.top = `${y}px`;
                    noteDiv.style.left = `${x}px`;
                    noteDiv.style.width = `${width}px`;
                    noteDiv.style.height = `${NOTE_HEIGHT - 2}px`;
                    noteDiv.style.backgroundColor = color;
                    noteDiv.style.opacity = note.velocity * 0.7 + 0.3;
                    noteDiv.title = `Track ${trackIndex + 1}\nNote: ${note.name}\nTime: ${note.time.toFixed(2)}s\nVel: ${Math.round(note.velocity * 100)}%`;
                    noteContainer.appendChild(noteDiv);
                });
            });
        }

        function drawTimeline() {
            timelineContainer.innerHTML = '';
            
            // Calculate timeline parameters
            const beatsPerMeasure = Tone.Transport.timeSignature[0];
            const secondsPerBeat = 60 / Tone.Transport.bpm.value;
            const secondsPerMeasure = secondsPerBeat * beatsPerMeasure;
            const secondsPerSubdivision = secondsPerBeat / (currentSubdivision / 4);
            
            // Determine total duration - either from MIDI or default minimum
            const midiDuration = midiData ? midiData.duration : 0;
            const minDuration = maxMeasures * secondsPerMeasure;
            const totalDuration = Math.max(midiDuration, minDuration);
            
            const containerWidth = totalDuration * zoom;
            timelineContainer.style.width = `${containerWidth}px`;
            timelineContainer.style.position = 'relative';
            timelineContainer.style.zIndex = '35';
            
            // Calculate subdivision count
            const totalSubdivisions = Math.ceil(totalDuration / secondsPerSubdivision);
            
            for (let i = 0; i <= totalSubdivisions; i++) {
                const time = i * secondsPerSubdivision;
                const x = time * zoom;
                
                // Skip if beyond our view to optimize performance
                if (x > containerWidth) break;
                
                // Determine tick type
                const subdivisionInMeasure = i % (beatsPerMeasure * currentSubdivision / 4);
                const subdivisionInBeat = i % (currentSubdivision / 4);
                
                const tick = document.createElement('div');
                tick.className = 'timeline-tick';
                tick.style.left = `${x}px`;
                tick.style.position = 'absolute';
                
                if (subdivisionInMeasure === 0) {
                    // Measure marker
                    const measure = Math.floor(i / (beatsPerMeasure * currentSubdivision / 4)) + 1;
                    tick.classList.add('measure');
                    tick.textContent = measure.toString();
                    tick.style.zIndex = '40';
                } else if (subdivisionInBeat === 0) {
                    // Beat marker
                    const beatInMeasure = Math.floor(subdivisionInMeasure / (currentSubdivision / 4)) + 1;
                    tick.classList.add('beat');
                    tick.style.zIndex = '37';
                    if (currentSubdivision >= 8) { // Only show beat numbers on fine subdivisions
                        tick.textContent = beatInMeasure.toString();
                    }
                } else {
                    // Subdivision marker
                    tick.classList.add('subdivision');
                    tick.style.zIndex = '35';
                    if (currentSubdivision >= 16) { // Only show subdivision numbers on very fine subdivisions
                        const subInBeat = (subdivisionInMeasure % (currentSubdivision / 4)) + 1;
                        tick.textContent = subInBeat.toString();
                    }
                }
                
                timelineContainer.appendChild(tick);
            }
        }

        // --- Sampler Logic ---
        pianoKeysSVG.addEventListener('click', async (e) => {
            if (!e.target.dataset.midi) return;
            const midi = parseInt(e.target.dataset.midi);
            const noteName = Tone.Midi(midi).toNote();
            alert(`Click a key to play. To load a sample for ${noteName}, create an input element.`);
            // Existing sampler loading logic preserved
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'audio/*';
            fileInput.onchange = async (ev) => {
                const file = ev.target.files[0];
                if (!file) return;
                const url = URL.createObjectURL(file);
                sampler.add(noteName, url, () => {
                    console.log(`Sample for ${noteName} loaded.`);
                    samplesLoaded = true;
                    alert(`Sample for ${noteName} loaded successfully!`);
                });
            };
            fileInput.click();
        });

        // --- Playback Controls ---
        function handlePlayPause() {
            if (Tone.Transport.state === 'started') {
                Tone.Transport.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                stopPlaybackUpdates();
            } else {
                if (!midiData && !isLooping) {
                    // Create a default empty track for practice
                    midiData = new Midi();
                    midiData.addTrack();
                    exportButton.disabled = false;
                }
                
                prepareParts();
                Tone.Transport.start();
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                showPlaybackCursor();
                startPlaybackUpdates();
            }
        }

        function handleStop() {
            Tone.Transport.stop();
            Tone.Transport.position = 0;
            parts.forEach(p => { p.stop(0); p.dispose(); });
            parts = [];
            synths.forEach(s => s.dispose());
            synths = [];
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            hidePlaybackCursor();
            stopPlaybackUpdates();
            updatePlaybackDisplay();
        }

        function handleRewind() {
            if (isLooping) {
                Tone.Transport.seconds = loopStart;
            } else {
                Tone.Transport.position = 0;
            }
            updatePlaybackCursor();
            updatePlaybackDisplay();
        }

        function prepareParts() {
            if (parts.length > 0) handleStop();
            if (!midiData) return;

            midiData.tracks.forEach(track => {
                if (track.notes.length === 0) return;
                const instrument = samplesLoaded ? sampler : new Tone.PolySynth(Tone.Synth).toDestination();
                if (!samplesLoaded) synths.push(instrument);

                const part = new Tone.Part((time, note) => {
                    instrument.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                }, track.notes).start(0);
                parts.push(part);
            });
        }

        function startPlaybackUpdates() {
            stopPlaybackUpdates();
            playbackUpdateInterval = setInterval(() => {
                updatePlaybackDisplay();
                
                // Handle looping
                if (isLooping && Tone.Transport.seconds >= loopEnd) {
                    Tone.Transport.seconds = loopStart;
                }
            }, 50); // 20fps updates
        }

        function stopPlaybackUpdates() {
            if (playbackUpdateInterval) {
                clearInterval(playbackUpdateInterval);
                playbackUpdateInterval = null;
            }
        }

        // --- Playback Cursor ---
        let cursorAnimationFrame = null;

        function showPlaybackCursor() {
            playbackCursor.style.display = 'block';
            updatePlaybackCursor();
        }

        function hidePlaybackCursor() {
            playbackCursor.style.display = 'none';
            if (cursorAnimationFrame) {
                cancelAnimationFrame(cursorAnimationFrame);
                cursorAnimationFrame = null;
            }
        }

        function updatePlaybackCursor() {
            if (Tone.Transport.state !== 'started') {
                const x = Tone.Transport.seconds * zoom;
                playbackCursor.style.transform = `translateX(${x}px)`;
                if (Tone.Transport.state === "stopped") hidePlaybackCursor();
                return;
            }
            const x = Tone.Transport.seconds * zoom;
            playbackCursor.style.transform = `translateX(${x}px)`;

            const gridRect = gridContainer.getBoundingClientRect();
            if (x > gridContainer.scrollLeft + gridRect.width - 50) {
                gridContainer.scrollLeft = x - gridRect.width + 50;
            } else if (x < gridContainer.scrollLeft + 50) {
                gridContainer.scrollLeft = Math.max(0, x - 50);
            }
            
            cursorAnimationFrame = requestAnimationFrame(updatePlaybackCursor);
        }
    </script>
</body>
</html>