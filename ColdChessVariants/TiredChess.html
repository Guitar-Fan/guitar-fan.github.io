<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tired Chess - Image Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            font-family: 'Fredoka One', cursive;
        }

        @keyframes sun-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px 20px #fef08a, 0 0 60px 40px #fde047, inset 0 0 20px 10px #fef9c3;
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 50px 25px #fef08a, 0 0 70px 50px #fde047, inset 0 0 20px 10px #fef9c3;
            }
        }
        
        @keyframes recover-animation {
            0% { transform: scale(1) rotate(15deg); opacity: 0.5; filter: grayscale(80%); }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; filter: grayscale(0%); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; filter: grayscale(0%); }
        }
        
        .sun {
            animation: sun-pulse 5s infinite ease-in-out;
        }
        
        .piece.recovering {
            animation: recover-animation 0.5s ease-out;
        }
        
        .piece {
             transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease, filter 0.4s ease;
        }

        .piece.tired .piece-image {
            opacity: 0.5;
            filter: grayscale(80%);
            transform: rotate(15deg) scale(0.9);
        }
    </style>
</head>
<body class="bg-sky-500 overflow-hidden">

    <div class="relative w-screen h-screen flex flex-col items-center justify-center p-4">
        <!-- Sun in the corner -->
        <div class="sun absolute top-8 left-8 w-24 h-24 sm:w-32 sm:h-32 bg-yellow-300 rounded-full"></div>
        
        <!-- Game Title -->
        <h1 class="text-4xl sm:text-6xl text-white text-center font-bold mb-4" style="text-shadow: 3px 3px 0px rgba(0,0,0,0.2);">Tired Chess</h1>

        <!-- Status Panel -->
        <div id="status-panel" class="bg-white/70 backdrop-blur-sm rounded-lg shadow-lg px-6 py-2 mb-4 text-xl sm:text-2xl text-gray-800">
            <div id="game-status">Current Turn: <span id="turn-indicator" class="font-bold text-sky-700">White</span></div>
            <div id="check-indicator" class="text-red-600 font-bold hidden">CHECK!</div>
        </div>

        <!-- Promotion Modal -->
        <div id="promotion-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm hidden items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 shadow-2xl">
                <h3 class="text-2xl font-bold mb-4 text-center">Choose Promotion</h3>
                <div class="flex gap-4">
                    <button id="promote-queen" class="p-4 bg-yellow-400 hover:bg-yellow-500 rounded-lg transition-colors">
                        <img class="w-16 h-16" alt="Queen">
                        <div class="text-sm font-bold mt-2">Queen</div>
                    </button>
                    <button id="promote-rook" class="p-4 bg-blue-400 hover:bg-blue-500 rounded-lg transition-colors">
                        <img class="w-16 h-16" alt="Rook">
                        <div class="text-sm font-bold mt-2">Rook</div>
                    </button>
                    <button id="promote-bishop" class="p-4 bg-green-400 hover:bg-green-500 rounded-lg transition-colors">
                        <img class="w-16 h-16" alt="Bishop">
                        <div class="text-sm font-bold mt-2">Bishop</div>
                    </button>
                    <button id="promote-knight" class="p-4 bg-purple-400 hover:bg-purple-500 rounded-lg transition-colors">
                        <img class="w-16 h-16" alt="Knight">
                        <div class="text-sm font-bold mt-2">Knight</div>
                    </button>
                </div>
            </div>
        </div>

        <!-- Chessboard -->
        <div id="chessboard" class="grid grid-cols-8 w-[90vmin] h-[90vmin] sm:w-[80vmin] sm:h-[80vmin] shadow-2xl rounded-lg overflow-hidden border-4 border-yellow-800/50">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('chessboard');
            const turnIndicator = document.getElementById('turn-indicator');
            let board = [];
            let currentPlayer = 'white';
            let selectedPiece = null;
            let validMoves = [];
            let enPassantTarget = null; // {row, col} of square that can be captured en passant
            let gameState = 'playing'; // 'playing', 'check', 'checkmate', 'stalemate', 'draw'
            let gameHistory = []; // For threefold repetition detection
            let isPromoting = false;
            let promotionSquare = null;

            // --- Game Configuration ---
            const PIECE_MAX_MOVES = {
                queen: 9,
                rook: 5,
                bishop: 3,
                knight: 3,
                pawn: 1,
                king: 999 
            };
            
            const PIECE_IMAGES = {
                white: {
                    pawn: 'pieces/WhitePawn.png',
                    rook: 'pieces/WhiteRook.png',
                    knight: 'pieces/WhiteKnight.png',
                    bishop: 'pieces/WhiteBishop.png',
                    queen: 'pieces/WhiteQueen.png',
                    king: 'pieces/WhiteKing.png',
                },
                black: {
                    pawn: 'pieces/BlackPawn.png',
                    rook: 'pieces/BlackRook.png',
                    knight: 'pieces/BlackKnight.png',
                    bishop: 'pieces/BlackBishop.png',
                    queen: 'pieces/BlackQueen.webp',
                    king: 'pieces/BlackKing.png',
                }
            };

            function setupBoard() {
                const initialSetup = [
                    ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                    ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                    [], [], [], [],
                    ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                    ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook']
                ];

                for (let r = 0; r < 8; r++) {
                    board[r] = new Array(8).fill(null);
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        const bgColor = (r + c) % 2 === 0 ? 'bg-green-400' : 'bg-green-600';
                        square.className = `square flex justify-center items-center relative ${bgColor}`;
                        square.dataset.row = r;
                        square.dataset.col = c;
                        boardElement.appendChild(square);
                    }
                }

                initialSetup.forEach((rowSetup, rowIndex) => {
                    const row = rowIndex < 4 ? rowIndex : 7 - (7 - rowIndex);
                    const color = rowIndex < 4 ? 'black' : 'white';
                    if (rowSetup.length > 0) {
                        rowSetup.forEach((pieceType, col) => {
                             board[row][col] = { type: pieceType, color: color, movesLeft: PIECE_MAX_MOVES[pieceType], tiredTurns: 0 };
                        });
                    }
                });
                renderBoard();
            }

            function createPieceElement(pieceData) {
                const pieceWrapper = document.createElement('div');
                pieceWrapper.className = 'piece p-1 w-full h-full absolute top-0 left-0 flex justify-center items-center cursor-pointer';
                
                const pieceImage = document.createElement('img');
                pieceImage.src = PIECE_IMAGES[pieceData.color][pieceData.type];
                // In case an image link is broken, this prevents an ugly icon from showing
                pieceImage.onerror = (e) => { e.target.style.display = 'none'; }; 
                pieceImage.className = 'piece-image w-full h-full object-contain transition-all duration-300';
                
                // Add a white drop-shadow to black pieces to make them pop from the dark squares
                if (pieceData.color === 'black') {
                    pieceImage.style.filter = 'drop-shadow(2px 2px 2px rgba(255,255,255,0.3))';
                } else {
                     pieceImage.style.filter = 'drop-shadow(2px 2px 2px rgba(0,0,0,0.3))';
                }

                const moveCounter = document.createElement('div');
                moveCounter.className = 'move-count absolute bottom-0 right-0 text-sm font-bold text-white bg-black/60 rounded-full w-5 h-5 flex items-center justify-center';
                moveCounter.textContent = pieceData.type === 'king' ? 'âˆž' : pieceData.movesLeft;

                pieceWrapper.appendChild(pieceImage);
                pieceWrapper.appendChild(moveCounter);

                if (pieceData.movesLeft === 0) {
                    pieceWrapper.classList.add('tired', 'cursor-not-allowed');
                }
                return pieceWrapper;
            }

            function renderBoard() {
                document.querySelectorAll('.piece, .valid-move-dot, .capture-move').forEach(el => el.remove());
                document.querySelectorAll('.square.bg-yellow-400\\/60').forEach(sq => sq.classList.remove('bg-yellow-400/60', 'rounded-lg'));
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const pieceData = board[r][c];
                        if (pieceData) {
                            const pieceElement = createPieceElement(pieceData);
                            getSquareElement(r, c).appendChild(pieceElement);
                        }
                    }
                }
            }
            
            function handleSquareClick(event) {
                if (gameState === 'checkmate' || gameState === 'stalemate' || gameState === 'draw' || isPromoting) return;
                
                const square = event.target.closest('.square');
                if (!square) return;
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const clickedPiece = board[row][col];

                if (selectedPiece) {
                    const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
                    if (isValidMove) {
                        movePiece(selectedPiece, row, col);
                    } else if (clickedPiece && clickedPiece.color === currentPlayer && clickedPiece.movesLeft > 0) {
                        selectedPiece = { piece: clickedPiece, row, col };
                        validMoves = getValidMoves(clickedPiece, row, col);
                        showHighlights();
                    } else {
                        selectedPiece = null;
                        validMoves = [];
                        showHighlights();
                    }
                } else if (clickedPiece && clickedPiece.color === currentPlayer && clickedPiece.movesLeft > 0) {
                    selectedPiece = { piece: clickedPiece, row, col };
                    validMoves = getValidMoves(clickedPiece, row, col);
                    showHighlights();
                }
            }
            
            function getValidMoves(piece, row, col, checkLegal = true) {
                const moves = [];
                const { type, color } = piece;
                const directions = {
                    rook: [[0, 1], [0, -1], [1, 0], [-1, 0]],
                    bishop: [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                    queen: [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                    king: [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
                };

                if (["rook", "bishop", "queen"].includes(type)) {
                    for (const [dr, dc] of directions[type]) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + i * dr, newCol = col + i * dc;
                            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                            if (board[newRow][newCol]) {
                                if (board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                                break;
                            }
                            moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "knight") {
                    const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
                    for (const [dr, dc] of knightMoves) {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!board[newRow][newCol] || board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "king") {
                    for (const [dr, dc] of directions.king) {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!board[newRow][newCol] || board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "pawn") {
                    const dir = color === "white" ? -1 : 1;
                    const startRow = color === "white" ? 6 : 1;
                    // Forward move
                    if (row + dir >= 0 && row + dir < 8 && !board[row + dir][col]) {
                        moves.push([row + dir, col]);
                        if (row === startRow && !board[row + 2 * dir][col]) moves.push([row + 2 * dir, col]);
                    }
                    // Captures
                    for (const dc of [-1, 1]) {
                        const targetRow = row + dir;
                        const targetCol = col + dc;
                        if (targetCol >= 0 && targetCol < 8 && targetRow >= 0 && targetRow < 8) {
                            // Normal capture
                            if (board[targetRow] && board[targetRow][targetCol] && board[targetRow][targetCol].color !== color) {
                                moves.push([targetRow, targetCol]);
                            }
                            // En passant
                            if (
                                enPassantTarget &&
                                enPassantTarget.row === targetRow &&
                                enPassantTarget.col === targetCol &&
                                ((color === "white" && row === 3) || (color === "black" && row === 4))
                            ) {
                                moves.push([targetRow, targetCol]);
                            }
                        }
                    }
                }
                
                // Filter out illegal moves that would leave king in check
                if (checkLegal) {
                    return moves.filter(([toRow, toCol]) => isLegalMove(row, col, toRow, toCol));
                }
                
                return moves;
            }

            function findKing(color) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] && board[r][c].type === 'king' && board[r][c].color === color) {
                            return [r, c];
                        }
                    }
                }
                return null;
            }

            function isSquareAttacked(row, col, byColor) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece.color === byColor) {
                            const moves = getValidMoves(piece, r, c, false);
                            if (moves.some(([mr, mc]) => mr === row && mc === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function isInCheck(color) {
                const kingPos = findKing(color);
                if (!kingPos) return false;
                return isSquareAttacked(kingPos[0], kingPos[1], color === 'white' ? 'black' : 'white');
            }

            function isLegalMove(fromRow, fromCol, toRow, toCol) {
                // Make the move temporarily
                const piece = board[fromRow][fromCol];
                const captured = board[toRow][toCol];
                const originalEnPassant = enPassantTarget;
                
                // Handle en passant capture
                let enPassantCaptured = null;
                if (piece.type === 'pawn' && enPassantTarget && 
                    toRow === enPassantTarget.row && toCol === enPassantTarget.col &&
                    Math.abs(toCol - fromCol) === 1) {
                    enPassantCaptured = board[fromRow][toCol];
                    board[fromRow][toCol] = null;
                }
                
                board[toRow][toCol] = piece;
                board[fromRow][fromCol] = null;
                
                const legal = !isInCheck(piece.color);
                
                // Restore the board
                board[fromRow][fromCol] = piece;
                board[toRow][toCol] = captured;
                if (enPassantCaptured) {
                    board[fromRow][toCol] = enPassantCaptured;
                }
                enPassantTarget = originalEnPassant;
                
                return legal;
            }

            function getAllLegalMoves(color) {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece.color === color && piece.movesLeft > 0) {
                            const pieceMoves = getValidMoves(piece, r, c, true);
                            pieceMoves.forEach(([toR, toC]) => {
                                moves.push({from: [r, c], to: [toR, toC], piece});
                            });
                        }
                    }
                }
                return moves;
            }

            function isCheckmate(color) {
                return isInCheck(color) && getAllLegalMoves(color).length === 0;
            }

            function isStalemate(color) {
                return !isInCheck(color) && getAllLegalMoves(color).length === 0;
            }

            function getBoardString() {
                let str = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece) {
                            str += piece.color[0] + piece.type[0];
                        } else {
                            str += '--';
                        }
                    }
                }
                return str;
            }

            function isThreefoldRepetition() {
                const currentPosition = getBoardString();
                let count = 0;
                for (const position of gameHistory) {
                    if (position === currentPosition) {
                        count++;
                        if (count >= 3) return true;
                    }
                }
                return false;
            }

            function updateGameState() {
                const opponent = currentPlayer === 'white' ? 'black' : 'white';
                const checkIndicator = document.getElementById('check-indicator');
                const gameStatus = document.getElementById('game-status');
                
                if (isCheckmate(currentPlayer)) {
                    gameState = 'checkmate';
                    gameStatus.innerHTML = `<span class="text-red-600 font-bold">CHECKMATE! ${opponent.charAt(0).toUpperCase() + opponent.slice(1)} wins!</span>`;
                    checkIndicator.classList.add('hidden');
                } else if (isStalemate(currentPlayer)) {
                    gameState = 'stalemate';
                    gameStatus.innerHTML = `<span class="text-yellow-600 font-bold">STALEMATE! It's a draw!</span>`;
                    checkIndicator.classList.add('hidden');
                } else if (isThreefoldRepetition()) {
                    gameState = 'draw';
                    gameStatus.innerHTML = `<span class="text-yellow-600 font-bold">DRAW! Threefold repetition!</span>`;
                    checkIndicator.classList.add('hidden');
                } else if (isInCheck(currentPlayer)) {
                    gameState = 'check';
                    gameStatus.innerHTML = `Current Turn: <span id="turn-indicator" class="font-bold text-sky-700">${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}</span>`;
                    checkIndicator.classList.remove('hidden');
                } else {
                    gameState = 'playing';
                    gameStatus.innerHTML = `Current Turn: <span id="turn-indicator" class="font-bold text-sky-700">${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}</span>`;
                    checkIndicator.classList.add('hidden');
                }
                
                const turnIndicator = document.getElementById('turn-indicator');
                if (turnIndicator) {
                    turnIndicator.style.color = currentPlayer === 'white' ? '#0369a1' : '#3f3f46';
                }
            }

            function showHighlights() {
                document.querySelectorAll('.valid-move-dot, .capture-move').forEach(el => el.remove());
                document.querySelectorAll('.square.bg-yellow-400\\/60').forEach(sq => sq.classList.remove('bg-yellow-400/60', 'rounded-lg'));
                
                if (selectedPiece) {
                    getSquareElement(selectedPiece.row, selectedPiece.col).classList.add('bg-yellow-400/60', 'rounded-lg');
                    validMoves.forEach(([r, c]) => {
                        const square = getSquareElement(r, c);
                        if(board[r][c]) {
                           square.innerHTML += `<div class="capture-move absolute top-0 left-0 w-full h-full border-4 border-red-500/80 rounded-lg"></div>`;
                        } else {
                           square.innerHTML += `<div class="valid-move-dot w-1/3 h-1/3 bg-yellow-200/80 rounded-full"></div>`;
                        }
                    });
                }
            }

            function movePiece(selection, newRow, newCol) {
                const { piece, row: oldRow, col: oldCol } = selection;
                const movingPieceElement = getSquareElement(oldRow, oldCol).querySelector('.piece');
                const newSquare = getSquareElement(newRow, newCol);
                const dx = newSquare.offsetLeft - movingPieceElement.parentElement.offsetLeft;
                const dy = newSquare.offsetTop - movingPieceElement.parentElement.offsetTop;

                movingPieceElement.style.transform = `translate(${dx}px, ${dy}px) scale(1.1)`;
                movingPieceElement.style.zIndex = 10;

                setTimeout(() => {
                    if (piece.type !== 'king') piece.movesLeft--;

                    // En passant capture
                    let didEnPassant = false;
                    if (
                        piece.type === 'pawn' &&
                        enPassantTarget &&
                        newRow === enPassantTarget.row &&
                        newCol === enPassantTarget.col &&
                        Math.abs(newCol - oldCol) === 1 &&
                        board[oldRow][newCol] && board[oldRow][newCol].type === 'pawn' && board[oldRow][newCol].color !== piece.color
                    ) {
                        // Remove the captured pawn
                        board[oldRow][newCol] = null;
                        didEnPassant = true;
                    }

                    board[newRow][newCol] = piece;
                    board[oldRow][oldCol] = null;

                    // Check for pawn promotion
                    if (piece.type === 'pawn' && (newRow === 0 || newRow === 7)) {
                        isPromoting = true;
                        promotionSquare = {row: newRow, col: newCol, piece};
                        showPromotionDialog(piece.color);
                        return; // Don't continue with turn logic until promotion is chosen
                    }

                    // Set en passant target
                    if (
                        piece.type === 'pawn' &&
                        Math.abs(newRow - oldRow) === 2
                    ) {
                        enPassantTarget = { row: (oldRow + newRow) / 2, col: oldCol };
                    } else {
                        enPassantTarget = null;
                    }

                    completeTurn();

                }, 300);
            }

            function completeTurn() {
                // Save board state for repetition detection
                gameHistory.push(getBoardString());

                const previousPlayer = currentPlayer;
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

                // Handle tired piece recovery - pieces need to be tired for 4 full turns (2 from each side)
                const piecesToRecover = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = board[r][c];
                        if (p) {
                            if (p.movesLeft === 0) {
                                p.tiredTurns++;
                                // Recover after 4 turns (2 from each side)
                                if (p.tiredTurns >= 4) {
                                    p.movesLeft = PIECE_MAX_MOVES[p.type];
                                    p.tiredTurns = 0;
                                    piecesToRecover.push({r, c});
                                }
                            } else {
                                p.tiredTurns = 0; // Reset tired counter if piece has moves
                            }
                        }
                    }
                }

                selectedPiece = null;
                validMoves = [];
                renderBoard();
                
                // Add recovery animation to pieces that just recovered
                piecesToRecover.forEach(({r, c}) => {
                    const recoveredElement = getSquareElement(r, c)?.querySelector('.piece');
                    if (recoveredElement && !recoveredElement.classList.contains('recovering')) {
                        recoveredElement.classList.add('recovering');
                        recoveredElement.addEventListener('animationend', () => {
                            recoveredElement.classList.remove('recovering');
                        }, { once: true });
                    }
                });

                // Update game state
                updateGameState();
            }

            function showPromotionDialog(color) {
                const modal = document.getElementById('promotion-modal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                
                // Set promotion piece images
                document.querySelector('#promote-queen img').src = PIECE_IMAGES[color]['queen'];
                document.querySelector('#promote-rook img').src = PIECE_IMAGES[color]['rook'];
                document.querySelector('#promote-bishop img').src = PIECE_IMAGES[color]['bishop'];
                document.querySelector('#promote-knight img').src = PIECE_IMAGES[color]['knight'];
            }

            function hidePromotionDialog() {
                const modal = document.getElementById('promotion-modal');
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            }

            function handlePromotion(pieceType) {
                if (!promotionSquare) return;
                
                const {row, col, piece} = promotionSquare;
                piece.type = pieceType;
                piece.movesLeft = PIECE_MAX_MOVES[pieceType];
                piece.tiredTurns = 0;
                
                isPromoting = false;
                promotionSquare = null;
                hidePromotionDialog();
                
                renderBoard();
                completeTurn();
            }

            function getSquareElement(row, col) {
                return boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
            }

            // Event listeners
            boardElement.addEventListener('click', handleSquareClick);
            
            document.getElementById('promote-queen').addEventListener('click', () => handlePromotion('queen'));
            document.getElementById('promote-rook').addEventListener('click', () => handlePromotion('rook'));
            document.getElementById('promote-bishop').addEventListener('click', () => handlePromotion('bishop'));
            document.getElementById('promote-knight').addEventListener('click', () => handlePromotion('knight'));
            
            setupBoard();
            updateGameState();
        });
    </script>
     <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</body>
</html>