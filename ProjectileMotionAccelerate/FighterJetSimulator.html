<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Babylon.js Fighter Jet Simulator</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://unpkg.com/@fontsource/rajdhani@5.0.8/index.css" rel="stylesheet" />
  <link href="https://unpkg.com/@fontsource/space-grotesk@5.0.8/index.css" rel="stylesheet" />
   <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
  <style>
    :root {
      --bg: #04070d;
      --panel: #0c1320;
      --panel-2: #0f1a2e;
      --panel-3: #13243d;
      --accent: #39d2ff;
      --accent-2: #ffb347;
      --accent-3: #ff5f6d;
      --hud: rgba(57, 210, 255, 0.15);
      --text: #d7e8ff;
      --grid: rgba(255, 255, 255, 0.05);
      --shadow: rgba(0, 0, 0, 0.45);
      --glow: 0 0 16px rgba(57, 210, 255, 0.4);
      --font-1: "Rajdhani", monospace;
      --font-2: "Space Grotesk", sans-serif;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-2);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    #renderCanvas {
      width: 100vw;
      height: 60vh;
      display: block;
      background: black;
    }
    #ui-shell {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 40vh;
      background: linear-gradient(180deg, rgba(6, 10, 18, 0.95), rgba(5, 8, 14, 0.98));
      border-top: 1px solid rgba(57, 210, 255, 0.15);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
      overflow: hidden;
    }
    #hud-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 60vh;
      pointer-events: none;
      color: var(--text);
      font-family: var(--font-1);
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
    }
    #hud-overlay .crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 64px;
      height: 64px;
      border: 1px solid rgba(57, 210, 255, 0.8);
      border-radius: 50%;
      box-shadow: var(--glow);
    }
    #hud-overlay .crosshair:before,
    #hud-overlay .crosshair:after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 2px;
      height: 64px;
      background: rgba(57, 210, 255, 0.6);
      transform: translate(-50%, -50%);
    }
    #hud-overlay .crosshair:after {
      width: 64px;
      height: 2px;
    }
    #hud-overlay .reticle-ring {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 220px;
      height: 220px;
      border: 1px dashed rgba(57, 210, 255, 0.35);
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(57, 210, 255, 0.2);
      animation: pulse 4s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { opacity: 0.55; }
      50% { opacity: 0.25; }
      100% { opacity: 0.55; }
    }
    #hud-overlay .telemetry {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.35);
      padding: 10px 12px;
      border: 1px solid rgba(57, 210, 255, 0.25);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      box-shadow: var(--glow);
      min-width: 240px;
    }
    #hud-overlay .telemetry h3 {
      font-size: 12px;
      letter-spacing: 0.12em;
      color: var(--accent);
      margin-bottom: 6px;
    }
    #hud-overlay .telemetry .row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 4px;
    }
    #hud-overlay .telemetry .row span.label {
      color: rgba(215, 232, 255, 0.8);
    }
    #hud-overlay .telemetry .row span.value {
      color: var(--accent-2);
    }
    #hud-overlay .upper-banner {
      position: absolute;
      top: 8px;
      right: 12px;
      display: flex;
      gap: 8px;
    }
    #hud-overlay .pill {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(57, 210, 255, 0.25);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: var(--glow);
    }
    #panel-header {
      display: flex;
      justify-content: space-between;
      padding: 12px 18px;
      border-bottom: 1px solid rgba(57, 210, 255, 0.18);
      background: linear-gradient(90deg, rgba(15, 26, 46, 0.85), rgba(10, 18, 32, 0.9));
    }
    #panel-header .title {
      font-family: var(--font-1);
      letter-spacing: 0.14em;
      font-size: 13px;
    }
    #panel-header .status-badges {
      display: flex;
      gap: 8px;
    }
    .badge {
      padding: 6px 10px;
      border-radius: 6px;
      background: rgba(57, 210, 255, 0.12);
      border: 1px solid rgba(57, 210, 255, 0.25);
      font-size: 11px;
      letter-spacing: 0.08em;
    }
    #dashboard {
      flex: 1;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 10px;
      padding: 12px 12px 14px 12px;
      overflow: hidden;
    }
    #control-board {
      background: radial-gradient(circle at 20% 20%, rgba(25, 45, 76, 0.5), rgba(10, 18, 32, 0.95));
      border: 1px solid rgba(57, 210, 255, 0.2);
      border-radius: 14px;
      box-shadow: inset 0 0 24px rgba(0, 0, 0, 0.55);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow: hidden;
      position: relative;
    }
    .board-content {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 18px;
      z-index: 1;
    }
    .tile {
      background: linear-gradient(180deg, rgba(17, 28, 46, 0.9), rgba(8, 14, 23, 0.95));
      border: 1px solid rgba(57, 210, 255, 0.2);
      border-radius: 8px;
      padding: 8px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 4px 12px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      color: var(--text);
      font-size: 12px;
      position: relative;
      overflow: hidden;
    }
    .tile::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(57, 210, 255, 0.04), rgba(57, 210, 255, 0));
      pointer-events: none;
    }
    .tile .label { letter-spacing: 0.06em; font-size: 11px; color: rgba(215, 232, 255, 0.7); }
    .tile .value { font-size: 15px; font-family: var(--font-1); color: var(--accent-2); }
    .tile .bar {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      border: 1px solid rgba(57, 210, 255, 0.18);
    }
    .tile .bar span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      width: 45%;
      box-shadow: var(--glow);
    }
    .board-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .section-title {
      font-size: 11px;
      letter-spacing: 0.14em;
      font-family: var(--font-1);
      color: rgba(215, 232, 255, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
    }
    .section-hint {
      font-family: var(--font-2);
      letter-spacing: 0;
      font-size: 11px;
      color: rgba(215, 232, 255, 0.55);
    }
    .section-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }
    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card {
      background: linear-gradient(180deg, rgba(17, 28, 46, 0.95), rgba(8, 14, 23, 0.98));
      border: 1px solid rgba(57, 210, 255, 0.2);
      border-radius: 10px;
      box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.45);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card.compact {
      gap: 6px;
    }
    .card h4 {
      font-family: var(--font-1);
      letter-spacing: 0.14em;
      font-size: 12px;
      color: var(--accent);
    }
    #tactical-map-card canvas {
      width: 100%;
      height: 220px;
      border-radius: 12px;
      border: 1px solid rgba(57, 210, 255, 0.25);
      background: radial-gradient(circle at 20% 20%, rgba(10, 18, 32, 0.85), rgba(4, 7, 13, 0.95));
      box-shadow: inset 0 0 24px rgba(0, 0, 0, 0.65);
    }
    #tactical-map-legend {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 10px;
      letter-spacing: 0.08em;
      color: rgba(215, 232, 255, 0.65);
    }
    #tactical-map-legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    #tactical-map-legend .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid rgba(57, 210, 255, 0.6);
      background: rgba(57, 210, 255, 0.35);
      box-shadow: 0 0 8px rgba(57, 210, 255, 0.4);
    }
    #tactical-map-legend .dot.missile {
      border-color: rgba(255, 179, 71, 0.8);
      background: rgba(255, 179, 71, 0.6);
      box-shadow: 0 0 8px rgba(255, 179, 71, 0.5);
    }
    .log {
      flex: 1;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(57, 210, 255, 0.1);
      border-radius: 8px;
      padding: 8px;
      overflow-y: auto;
      font-size: 11px;
      line-height: 1.4;
      color: #bcd3f7;
    }
    .control-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    .btn {
      padding: 8px;
      border-radius: 6px;
      text-align: center;
      border: 1px solid rgba(57, 210, 255, 0.25);
      background: rgba(57, 210, 255, 0.08);
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
      user-select: none;
    }
    .btn:hover { background: rgba(57, 210, 255, 0.18); }
    .btn:active { transform: translateY(1px); }
    .btn.small {
      padding: 6px 8px;
      font-size: 11px;
    }
    .btn.ghost {
      background: transparent;
      border-color: rgba(57, 210, 255, 0.3);
    }
    .btn.toggled {
      background: rgba(57, 210, 255, 0.25);
      border-color: rgba(57, 210, 255, 0.65);
      box-shadow: var(--glow);
    }
    .view-toggle {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .chip {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(57, 210, 255, 0.25);
      font-size: 11px;
      background: rgba(57, 210, 255, 0.08);
      letter-spacing: 0.05em;
    }
    .chip.ghost {
      background: transparent;
      border-style: dashed;
      cursor: pointer;
    }
    .chip strong { color: var(--accent-2); margin-left: 4px; }
    .drawer {
      max-height: 220px;
      overflow-y: auto;
      padding-right: 4px;
    }
    #assist-card label {
      font-size: 11px;
      letter-spacing: 0.08em;
      color: rgba(215, 232, 255, 0.8);
      display: flex;
      justify-content: space-between;
      text-transform: uppercase;
    }
    #assist-card input[type=range] {
      width: 100%;
      accent-color: var(--accent);
    }
    .assist-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    /* Decorative grids to add visual density */
    .grid-lines {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image: linear-gradient(var(--grid) 1px, transparent 1px), linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 60px 60px;
      opacity: 0.35;
    }
    /* Create many tiny indicators to fill board visuals */
    .led-row { display: flex; gap: 3px; flex-wrap: wrap; }
    .led {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 95, 109, 0.5);
      box-shadow: 0 0 6px rgba(255, 95, 109, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .led.green { background: rgba(87, 247, 158, 0.7); box-shadow: 0 0 6px rgba(87, 247, 158, 0.65); }
    .led.blue { background: rgba(57, 210, 255, 0.6); box-shadow: 0 0 6px rgba(57, 210, 255, 0.6); }
    .led.amber { background: rgba(255, 179, 71, 0.7); box-shadow: 0 0 6px rgba(255, 179, 71, 0.65); }
    /* More stylistic fillers */
    .dial {
      width: 100%;
      height: 36px;
      border-radius: 50px;
      background: radial-gradient(circle at 20% 20%, rgba(57, 210, 255, 0.25), rgba(57, 210, 255, 0.05));
      border: 1px solid rgba(57, 210, 255, 0.25);
      position: relative;
      overflow: hidden;
    }
    .dial .indicator {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 40%;
      background: linear-gradient(90deg, var(--accent-3), var(--accent));
      box-shadow: 0 0 10px rgba(255, 95, 109, 0.4);
    }
    #focus-indicator { display: none; }
    body.focus-mode #ui-shell {
      height: 72px;
      transition: height 0.3s ease, opacity 0.3s ease;
      opacity: 0.4;
    }
    body.focus-mode #dashboard {
      max-height: 0;
      height: 0;
      opacity: 0;
      pointer-events: none;
      overflow: hidden;
    }
    body.focus-mode #panel-header {
      border-bottom: none;
    }
    body.focus-mode #focus-indicator {
      display: inline-flex;
    }
    body.focus-mode #hud-overlay .telemetry {
      border-color: rgba(57, 210, 255, 0.4);
    }
    /* Scrollbar styling */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-thumb { background: rgba(57, 210, 255, 0.25); border-radius: 10px; border: 2px solid rgba(0,0,0,0.3); }
    ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.25); }
  </style>
  <script src="https://unpkg.com/earcut@3.0.2/dist/earcut.min.js"></script>
  <script src="https://unpkg.com/cannon@0.6.2/build/cannon.min.js"></script>
  <script src="https://unpkg.com/babylonjs@8.40.1/babylon.js"></script>
  <script src="https://unpkg.com/babylonjs-gui@8.40.1/babylon.gui.min.js"></script>
  <script src="https://unpkg.com/babylonjs-loaders@8.40.1/babylonjs.loaders.min.js"></script>
  <script src="https://unpkg.com/babylonjs-materials@8.40.1/babylonjs.materials.min.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="hud-overlay">
    <div class="crosshair"></div>
    <div class="reticle-ring"></div>
    <div class="upper-banner">
      <div class="pill" id="mode-pill">NAV MODE</div>
      <div class="pill" id="weapon-pill">SAFE</div>
      <div class="pill" id="status-pill">ENGINES HOT</div>
      <div class="pill" id="focus-indicator">PRESS H TO EXIT FOCUS</div>
    </div>
    <div class="telemetry">
      <h3>PILOT TELEMETRY</h3>
      <div class="row"><span class="label">Altitude</span><span class="value" id="hud-altitude">00000 ft</span></div>
      <div class="row"><span class="label">Airspeed</span><span class="value" id="hud-speed">000 kts</span></div>
      <div class="row"><span class="label">Heading</span><span class="value" id="hud-heading">000°</span></div>
      <div class="row"><span class="label">Pitch</span><span class="value" id="hud-pitch">0°</span></div>
      <div class="row"><span class="label">Roll</span><span class="value" id="hud-roll">0°</span></div>
      <div class="row"><span class="label">Throttle</span><span class="value" id="hud-throttle">0%</span></div>
    </div>
  </div>
  <div id="ui-shell">
    <div id="panel-header">
      <div class="title">ADVANCED FIGHTER JET SIMULATOR — BABYLON.JS</div>
      <div class="status-badges">
        <div class="badge" id="badge-fps">FPS: --</div>
        <div class="badge" id="badge-missiles">MISSILES: --</div>
        <div class="badge" id="badge-targets">TARGETS: --</div>
      </div>
    </div>
    <div id="dashboard">
      <div id="control-board">
        <div class="grid-lines"></div>
        <div class="board-content">
          <div class="board-section">
            <div class="section-title">
              FLIGHT STACK
              <span class="section-hint">Live input snapshot</span>
            </div>
            <div class="section-grid">
              <div class="tile"><div class="label">THROTTLE</div><div class="value" id="tile-throttle">0%</div><div class="bar"><span id="bar-throttle"></span></div></div>
              <div class="tile"><div class="label">PITCH</div><div class="value" id="tile-pitch">0°</div></div>
              <div class="tile"><div class="label">ROLL</div><div class="value" id="tile-roll">0°</div></div>
              <div class="tile"><div class="label">YAW RATE</div><div class="value" id="tile-yaw">0°/s</div></div>
              <div class="tile"><div class="label">AOA</div><div class="value" id="tile-aoa">0°</div><div class="dial"><div class="indicator" id="dial-aoa"></div></div></div>
              <div class="tile"><div class="label">FLIGHT MODE</div><div class="value" id="tile-flight-mode">MANUAL</div><div class="led-row"><div class="led green"></div><div class="led"></div><div class="led"></div></div></div>
            </div>
          </div>
          <div class="board-section">
            <div class="section-title">
              SYSTEMS & SAFETY
              <span class="section-hint">Quick-look</span>
            </div>
            <div class="section-grid">
              <div class="tile"><div class="label">FUEL</div><div class="value" id="tile-fuel">100%</div><div class="bar"><span id="bar-fuel" style="width: 100%"></span></div></div>
              <div class="tile"><div class="label">MASTER ARM</div><div class="value" id="tile-master-arm">SAFE</div></div>
              <div class="tile"><div class="label">AFTERBURN</div><div class="value" id="tile-afterburn">OFF</div><div class="led-row"><div class="led"></div><div class="led amber"></div><div class="led green"></div></div></div>
              <div class="tile"><div class="label">GEAR</div><div class="value" id="tile-gear">UP</div></div>
              <div class="tile"><div class="label">RADAR</div><div class="value" id="tile-radar">SWEEP</div><div class="bar"><span id="bar-radar" style="width: 70%"></span></div></div>
              <div class="tile"><div class="label">ICING</div><div class="value" id="tile-icing">CLEAR</div></div>
            </div>
          </div>
          <div class="board-section">
            <div class="section-title">
              DIAGNOSTICS
              <button class="chip ghost" id="btn-refresh-diagnostics">Shuffle</button>
            </div>
            <div class="drawer">
              <div class="chip-list" id="diagnostic-list"></div>
            </div>
          </div>
        </div>
      </div>
      <div id="right-panel">
        <div class="card">
          <h4>MISSION LOG</h4>
          <div class="log" id="mission-log"></div>
          <div class="control-grid">
            <div class="btn" id="btn-master-arm">Toggle Master Arm</div>
            <div class="btn" id="btn-afterburn">Afterburner</div>
            <div class="btn" id="btn-autopilot">Autopilot</div>
            <div class="btn" id="btn-reset-view">Recenter View</div>
            <div class="btn" id="btn-spawn-target">Spawn Target</div>
            <div class="btn" id="btn-clear-missiles">Clear Missiles</div>
            <div class="btn" id="btn-focus-mode">Focus Mode (H)</div>
          </div>
        </div>
        <div class="card">
          <h4>CHECKLIST / CONTROLS</h4>
          <div class="log" id="control-help">
            <div>W/S: Pitch | A/D: Roll | Q/E: Yaw</div>
            <div>Shift/Ctrl: Throttle +/- | F: Afterburner</div>
            <div>Space / Click: Fire missile</div>
            <div>R: Reset attitude | G: Gear toggle</div>
            <div>1: NAV mode | 2: WPN mode</div>
            <div>Mouse move: Fine pitch/roll</div>
            <div>H: Focus HUD toggle | Esc: Pointer unlock</div>
            <div>Pilot Assist sliders: Alt / heading lock</div>
          </div>
        </div>
        <div class="card compact" id="assist-card">
          <h4>PILOT ASSIST</h4>
          <label>Target Altitude <span id="assist-alt-label">400 ft</span></label>
          <input type="range" id="assist-alt" min="500" max="25000" step="100" value="400">
          <label>Target Heading <span id="assist-hdg-label">0°</span></label>
          <input type="range" id="assist-hdg" min="0" max="359" step="1" value="0">
          <div class="assist-actions">
            <div class="btn small" id="btn-match-flight">Match Current</div>
            <div class="btn small" id="btn-hold-alt">Alt Hold</div>
            <div class="btn small" id="btn-hold-hdg">Hdg Hold</div>
          </div>
        </div>
        <div class="card" id="tactical-map-card">
          <h4>TACTICAL MAP</h4>
          <canvas id="tactical-map" width="320" height="220"></canvas>
          <div id="tactical-map-legend">
            <span><span class="dot"></span> Flight</span>
            <span><span class="dot missile"></span> Missile</span>
          </div>
        </div>
        <div class="card compact" id="view-card">
          <h4>VIEW MODES</h4>
          <div class="view-toggle" id="camera-mode-group">
            <div class="btn small ghost" data-camera-mode="chase">Chase</div>
            <div class="btn small ghost" data-camera-mode="cockpit">Cockpit</div>
            <div class="btn small ghost" data-camera-mode="orbit">Orbit</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    const logEl = document.getElementById('mission-log');
    const ui = {
      hudAlt: document.getElementById('hud-altitude'),
      hudAltitude: document.getElementById('hud-altitude'),
      hudSpeed: document.getElementById('hud-speed'),
      hudHeading: document.getElementById('hud-heading'),
      hudPitch: document.getElementById('hud-pitch'),
      hudRoll: document.getElementById('hud-roll'),
      hudThrottle: document.getElementById('hud-throttle'),
      badgeFps: document.getElementById('badge-fps'),
      badgeMissiles: document.getElementById('badge-missiles'),
      badgeTargets: document.getElementById('badge-targets'),
      modePill: document.getElementById('mode-pill'),
      weaponPill: document.getElementById('weapon-pill'),
      statusPill: document.getElementById('status-pill'),
    };
    ui.badgeMissiles.textContent = 'MISSILES: ∞';
    const tileMasterArm = document.getElementById('tile-master-arm');
    tileMasterArm.textContent = 'ARMED';
    ui.weaponPill.textContent = 'ARMED';
    const crosshairEl = document.querySelector('#hud-overlay .crosshair');
    const focusBtn = document.getElementById('btn-focus-mode');
    const diagnosticsList = document.getElementById('diagnostic-list');
    const diagnosticsShuffleBtn = document.getElementById('btn-refresh-diagnostics');
    const altSlider = document.getElementById('assist-alt');
    const hdgSlider = document.getElementById('assist-hdg');
    const altLabel = document.getElementById('assist-alt-label');
    const hdgLabel = document.getElementById('assist-hdg-label');
    const matchFlightBtn = document.getElementById('btn-match-flight');
    const holdAltBtn = document.getElementById('btn-hold-alt');
    const holdHdgBtn = document.getElementById('btn-hold-hdg');
    const cameraModeGroup = document.getElementById('camera-mode-group');
    const cameraModeButtons = cameraModeGroup ? cameraModeGroup.querySelectorAll('[data-camera-mode]') : [];
    const autopilotBtn = document.getElementById('btn-autopilot');
    const FEET_PER_METER = 3.28084;
    const metersToFeet = (m) => m * FEET_PER_METER;
    const feetToMeters = (ft) => ft / FEET_PER_METER;
    const diagnosticsConfig = [
      { label: 'Hydraulics', values: ['Nominal', 'Check', 'Low'] },
      { label: 'ECM', values: ['Standby', 'Active', 'Pulse'] },
      { label: 'Data Link', values: ['Sync', 'Jammed', 'Retry'] },
      { label: 'Cooling', values: ['Stable', 'Watch', 'Hot'] },
      { label: 'OBOGS', values: ['Online', 'Purge', 'Fault'] },
      { label: 'Radar Health', values: ['Green', 'Degraded', 'Offline'] },
      { label: 'IFF', values: ['Secure', 'Alert', 'Hold'] },
      { label: 'Stealth Skin', values: ['Intact', 'Worn', 'Repair'] }
    ];
    const autopilot = { enabled: false, targetAlt: 400, targetHdg: 0, lockAlt: false, lockHdg: false };
    let focusActive = false;
    const tacticalCanvas = document.getElementById('tactical-map');
    const tacticalCtx = tacticalCanvas ? tacticalCanvas.getContext('2d') : null;
    const tacticalMapState = { boundary: 2000, pulse: 0 };

    function applyStatusBanner() {
      if (focusActive) {
        ui.statusPill.textContent = 'FOCUS HUD';
        return;
      }
      if (autopilot.enabled && autopilot.lockAlt && autopilot.lockHdg) {
        ui.statusPill.textContent = 'ASSIST HOLD';
      } else if (autopilot.enabled && (autopilot.lockAlt || autopilot.lockHdg)) {
        ui.statusPill.textContent = autopilot.lockAlt ? 'ALT HOLD' : 'HDG HOLD';
      } else if (autopilot.enabled) {
        ui.statusPill.textContent = 'AUTOPILOT';
      } else {
        ui.statusPill.textContent = 'ENGINES HOT';
      }
    }

    function toggleFocusMode(force) {
      const next = typeof force === 'boolean' ? force : !focusActive;
      focusActive = next;
      document.body.classList.toggle('focus-mode', focusActive);
      if (focusBtn) focusBtn.classList.toggle('toggled', focusActive);
      applyStatusBanner();
      addLog('Focus mode ' + (focusActive ? 'enabled' : 'disabled'));
    }

    function refreshDiagnostics(initial = false) {
      if (!diagnosticsList) return;
      diagnosticsList.innerHTML = '';
      diagnosticsConfig.forEach((item) => {
        const chip = document.createElement('div');
        chip.className = 'chip';
        const value = initial ? item.values[0] : item.values[Math.floor(Math.random() * item.values.length)];
        chip.innerHTML = item.label.toUpperCase() + ' <strong>' + value.toUpperCase() + '</strong>';
        diagnosticsList.appendChild(chip);
      });
    }

    refreshDiagnostics(true);
    applyStatusBanner();
    if (diagnosticsShuffleBtn) diagnosticsShuffleBtn.addEventListener('click', () => refreshDiagnostics(false));
    if (focusBtn) focusBtn.addEventListener('click', () => toggleFocusMode());

    function updateCrosshairVisual(state) {
      const s = state || { x: input.crosshairX, y: input.crosshairY };
      if (crosshairEl) crosshairEl.style.transform = 'translate(' + s.x + 'px,' + s.y + 'px)';
    }

    function addLog(line) {
      const ts = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.textContent = `[${ts}] ${line}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

    class ProjectilePhysicsEngine {
      constructor(config, initialState) {
        const defaults = {
          gravity: 9.81,
          airDensity: 1.225,
          dragCoefficient: 0.47,
          mass: 1,
          area: 0.01,
          dragModel: 'quadratic',
          integrator: 'rk4',
          linearDrag: 0,
          variableGravity: true,
          variableDensity: true,
          scaleHeight: 8500,
          earthRadius: 6371000,
          windVector: new BABYLON.Vector3()
        };
        this.config = { ...defaults, ...config };
        this.config.windVector = config.windVector ? config.windVector.clone() : defaults.windVector.clone();
        this.linearDragOverMass = this.config.linearDrag / this.config.mass;
        this.state = {
          position: initialState.position.clone(),
          velocity: initialState.velocity.clone()
        };
        this.elapsed = 0;
      }

      setWind(vector) {
        this.config.windVector.copyFrom(vector);
      }

      getSpeed() {
        return this.state.velocity.length();
      }

      step(dt) {
        // Equations (20)-(24): classical RK4 integrator defaults with Euler fallback
        if (this.config.integrator === 'rk4') {
          this.state = this.rk4Step(this.state, dt);
        } else {
          this.state = this.eulerStep(this.state, dt);
        }
        this.elapsed += dt;
        return this.state;
      }

      gravityAtAltitude(height) {
        if (!this.config.variableGravity) return this.config.gravity;
        const alt = Math.max(0, height);
        const denom = this.config.earthRadius + alt;
        return this.config.gravity * Math.pow(this.config.earthRadius / denom, 2);
      }

      densityAtAltitude(height) {
        if (!this.config.variableDensity) return this.config.airDensity;
        const alt = Math.max(0, height);
        return this.config.airDensity * Math.exp(-alt / this.config.scaleHeight);
      }

      acceleration(state) {
        // Equation (15): state derivative formed from gravity plus drag components
        const accel = new BABYLON.Vector3(0, -this.gravityAtAltitude(state.position.y), 0);
        if (this.config.dragModel === 'none') {
          return accel;
        }

        const relativeVelocity = state.velocity.clone().subtract(this.config.windVector);
        const speed = relativeVelocity.length();
        if (speed < 0.0001) {
          return accel;
        }

        if (this.config.dragModel === 'linear' && this.linearDragOverMass > 0) {
          // Linear drag extension (Section 4.1)
          accel.addInPlace(relativeVelocity.scale(-this.linearDragOverMass));
          return accel;
        }

        // Equations (12)-(14): quadratic drag using k = 0.5 * Cd * rho * A / m
        const rho = this.densityAtAltitude(state.position.y);
        const k = 0.5 * this.config.dragCoefficient * rho * this.config.area / this.config.mass;
        accel.addInPlace(relativeVelocity.scale(-k * speed));
        return accel;
      }

      rk4Step(state, dt) {
        const k1Pos = state.velocity.clone();
        const k1Vel = this.acceleration(state);

        const state2 = {
          position: state.position.clone().add(k1Pos.clone().scale(dt * 0.5)),
          velocity: state.velocity.clone().add(k1Vel.clone().scale(dt * 0.5))
        };
        const k2Pos = state2.velocity.clone();
        const k2Vel = this.acceleration(state2);

        const state3 = {
          position: state.position.clone().add(k2Pos.clone().scale(dt * 0.5)),
          velocity: state.velocity.clone().add(k2Vel.clone().scale(dt * 0.5))
        };
        const k3Pos = state3.velocity.clone();
        const k3Vel = this.acceleration(state3);

        const state4 = {
          position: state.position.clone().add(k3Pos.clone().scale(dt)),
          velocity: state.velocity.clone().add(k3Vel.clone().scale(dt))
        };
        const k4Pos = state4.velocity.clone();
        const k4Vel = this.acceleration(state4);

        const newPosition = state.position.clone()
          .add(k1Pos.scale(dt / 6))
          .add(k2Pos.scale(dt / 3))
          .add(k3Pos.scale(dt / 3))
          .add(k4Pos.scale(dt / 6));
        const newVelocity = state.velocity.clone()
          .add(k1Vel.scale(dt / 6))
          .add(k2Vel.scale(dt / 3))
          .add(k3Vel.scale(dt / 3))
          .add(k4Vel.scale(dt / 6));
        return { position: newPosition, velocity: newVelocity };
      }

      eulerStep(state, dt) {
        // Equations (16)-(19): simple Euler advance
        const accel = this.acceleration(state);
        const newVelocity = state.velocity.clone().add(accel.clone().scale(dt));
        const newPosition = state.position.clone().add(state.velocity.clone().scale(dt));
        return { position: newPosition, velocity: newVelocity };
      }
    }

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.02, 0.03, 0.06, 1);
      scene.ambientColor = new BABYLON.Color3(0.05, 0.08, 0.12);

      const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.65;
      const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.6, -1, -0.2), scene);
      sun.position = new BABYLON.Vector3(500, 800, 500);
      sun.intensity = 2.2;
      sun.shadowMinZ = 1;
      sun.shadowMaxZ = 4000;
      const shadowGen = new BABYLON.ShadowGenerator(4096, sun);
      shadowGen.useBlurCloseExponentialShadowMap = true;
      shadowGen.blurKernel = 16;

      const skybox = BABYLON.MeshBuilder.CreateBox('skyBox', { size: 8000 }, scene);
      const skyMat = new BABYLON.StandardMaterial('skyMat', scene);
      skyMat.backFaceCulling = false;
      skyMat.disableLighting = true;
      const skyTex = new BABYLON.DynamicTexture('skyGradient', { width: 2, height: 512 }, scene, false);
      const skyCtx = skyTex.getContext();
      const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 512);
      skyGrad.addColorStop(0, '#081633');
      skyGrad.addColorStop(0.4, '#12345c');
      skyGrad.addColorStop(0.75, '#3c6ea5');
      skyGrad.addColorStop(1, '#9fd4ff');
      skyCtx.fillStyle = skyGrad;
      skyCtx.fillRect(0, 0, 2, 512);
      skyTex.update();
      skyTex.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
      skyTex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
      skyTex.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
      skyMat.emissiveTexture = skyTex;
      skyMat.emissiveColor = new BABYLON.Color3(0.35, 0.4, 0.45);
      skybox.material = skyMat;

      const terrain = BABYLON.MeshBuilder.CreateGround('terrain', { width: 6000, height: 6000, subdivisions: 180 }, scene);
      const positions = terrain.getVerticesData(BABYLON.VertexBuffer.PositionKind);
      const normals = [];
      const seed = 1337;
      function hash(x, y) {
        const s = Math.sin(x * 127.1 + y * 311.7 + seed) * 43758.5453;
        return s - Math.floor(s);
      }
      function noise(x, y) {
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        const fx = x - ix;
        const fy = y - iy;
        const a = hash(ix, iy);
        const b = hash(ix + 1, iy);
        const c = hash(ix, iy + 1);
        const d = hash(ix + 1, iy + 1);
        const u = fx * fx * (3 - 2 * fx);
        const v = fy * fy * (3 - 2 * fy);
        return BABYLON.Scalar.Lerp(a, b, u) + (c - a) * v * (1 - u) + (d - b) * u * v;
      }
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i] * 0.004;
        const z = positions[i + 2] * 0.004;
        const h = (noise(x, z) + noise(x * 0.4, z * 0.4) * 0.5 + noise(x * 0.1, z * 0.1) * 0.25) * 180 - 40;
        positions[i + 1] = h;
      }
      terrain.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      BABYLON.VertexData.ComputeNormals(positions, terrain.getIndices(), normals);
      terrain.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
      const terrainMat = new BABYLON.StandardMaterial('terrainMat', scene);
      terrainMat.diffuseColor = new BABYLON.Color3(0.23, 0.36, 0.18);
      terrainMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
      terrainMat.emissiveColor = new BABYLON.Color3(0.02, 0.04, 0.02);
      terrain.material = terrainMat;
      terrain.receiveShadows = true;
      shadowGen.addShadowCaster(terrain);

      const water = BABYLON.MeshBuilder.CreateGround('water', { width: 6000, height: 6000, subdivisions: 8 }, scene);
      water.position.y = -35;
      const waterMat = new BABYLON.StandardMaterial('waterMat', scene);
      waterMat.alpha = 0.8;
      waterMat.diffuseColor = new BABYLON.Color3(0.05, 0.18, 0.27);
      waterMat.specularColor = new BABYLON.Color3(0.2, 0.4, 0.6);
      water.material = waterMat;

      const cloudSystem = new BABYLON.ParticleSystem('clouds', 2000, scene);
      const cloudTex = new BABYLON.DynamicTexture('cloudSprite', { width: 256, height: 256 }, scene, true);
      const cloudCtx = cloudTex.getContext();
      const cloudGrad = cloudCtx.createRadialGradient(128, 128, 10, 128, 128, 128);
      cloudGrad.addColorStop(0, 'rgba(255,255,255,0.18)');
      cloudGrad.addColorStop(0.6, 'rgba(255,255,255,0.08)');
      cloudGrad.addColorStop(1, 'rgba(255,255,255,0)');
      cloudCtx.fillStyle = cloudGrad;
      cloudCtx.fillRect(0, 0, 256, 256);
      cloudTex.update();
      cloudSystem.particleTexture = cloudTex;
      cloudSystem.emitter = new BABYLON.Vector3(0, 400, 0);
      cloudSystem.minEmitBox = new BABYLON.Vector3(-2000, -50, -2000);
      cloudSystem.maxEmitBox = new BABYLON.Vector3(2000, 50, 2000);
      cloudSystem.minSize = 120;
      cloudSystem.maxSize = 240;
      cloudSystem.minLifeTime = 9999;
      cloudSystem.maxLifeTime = 9999;
      cloudSystem.emitRate = 200;
      cloudSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
      cloudSystem.color1 = new BABYLON.Color4(1, 1, 1, 0.08);
      cloudSystem.color2 = new BABYLON.Color4(1, 1, 1, 0.05);
      cloudSystem.start();

      const explosionTexture = new BABYLON.DynamicTexture('explosionTex', { width: 256, height: 256 }, scene, true);
      const explosionCtx = explosionTexture.getContext();
      const explosionGrad = explosionCtx.createRadialGradient(128, 128, 6, 128, 128, 128);
      explosionGrad.addColorStop(0, 'rgba(255,255,255,1)');
      explosionGrad.addColorStop(0.35, 'rgba(255,214,120,0.9)');
      explosionGrad.addColorStop(0.7, 'rgba(255,120,40,0.5)');
      explosionGrad.addColorStop(1, 'rgba(20,8,2,0)');
      explosionCtx.fillStyle = explosionGrad;
      explosionCtx.fillRect(0, 0, 256, 256);
      explosionTexture.update();

      const baseRoot = new BABYLON.TransformNode('baseRoot', scene);
      const runwayHeight = terrain.getHeightAtCoordinates(-320, -520) + 1;
      const runway = BABYLON.MeshBuilder.CreateBox('runway', { width: 90, height: 2, depth: 1800 }, scene);
      runway.position = new BABYLON.Vector3(-320, runwayHeight, -520);
      runway.rotationQuaternion = BABYLON.Quaternion.Identity();
      runway.parent = baseRoot;
      const runwayMat = new BABYLON.StandardMaterial('runwayMat', scene);
      runwayMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
      const runwayTex = new BABYLON.DynamicTexture('runwayTex', { width: 1024, height: 1024 }, scene, true);
      const runwayCtx = runwayTex.getContext();
      runwayCtx.fillStyle = '#1c1f28';
      runwayCtx.fillRect(0, 0, 1024, 1024);
      runwayCtx.strokeStyle = '#fefefe';
      runwayCtx.lineWidth = 36;
      for (let i = 80; i < 1024; i += 140) {
        runwayCtx.beginPath();
        runwayCtx.moveTo(512, i);
        runwayCtx.lineTo(512, i + 60);
        runwayCtx.stroke();
      }
      runwayCtx.fillStyle = '#f6c56b';
      runwayCtx.fillRect(470, 480, 108, 64);
      runwayTex.update();
      runwayMat.diffuseTexture = runwayTex;
      runway.material = runwayMat;
      runway.receiveShadows = true;

      const hangarMat = new BABYLON.StandardMaterial('hangarMat', scene);
      hangarMat.diffuseColor = new BABYLON.Color3(0.32, 0.35, 0.4);
      hangarMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.12);
      for (let i = 0; i < 3; i++) {
        const hangarBase = BABYLON.MeshBuilder.CreateBox('hangarBase-' + i, { width: 70, depth: 45, height: 18 }, scene);
        hangarBase.position = new BABYLON.Vector3(-220 + i * 80, terrain.getHeightAtCoordinates(-220 + i * 80, -400) + 9, -400);
        hangarBase.material = hangarMat;
        hangarBase.parent = baseRoot;
        const roof = BABYLON.MeshBuilder.CreateCylinder('hangarRoof-' + i, { height: 70, diameterTop: 45, diameterBottom: 45, tessellation: 24 }, scene);
        roof.scaling = new BABYLON.Vector3(1, 0.35, 1);
        roof.rotation.z = Math.PI / 2;
        roof.position = hangarBase.position.add(new BABYLON.Vector3(0, 18, 0));
        roof.material = hangarMat;
        roof.parent = baseRoot;
        shadowGen.addShadowCaster(hangarBase);
        shadowGen.addShadowCaster(roof);
      }

      const tower = BABYLON.MeshBuilder.CreateCylinder('controlTower', { height: 55, diameterTop: 6, diameterBottom: 8, tessellation: 16 }, scene);
      tower.position = new BABYLON.Vector3(-260, terrain.getHeightAtCoordinates(-260, -460) + 27, -460);
      const towerGlass = BABYLON.MeshBuilder.CreateCylinder('towerGlass', { height: 10, diameter: 16, tessellation: 24 }, scene);
      towerGlass.position = tower.position.add(new BABYLON.Vector3(0, 25, 0));
      const towerMat = new BABYLON.StandardMaterial('towerMat', scene);
      towerMat.diffuseColor = new BABYLON.Color3(0.28, 0.3, 0.32);
      tower.material = towerMat;
      const towerGlassMat = new BABYLON.StandardMaterial('towerGlassMat', scene);
      towerGlassMat.diffuseColor = new BABYLON.Color3(0.45, 0.65, 0.8);
      towerGlassMat.alpha = 0.5;
      towerGlass.material = towerGlassMat;
      tower.parent = baseRoot;
      towerGlass.parent = baseRoot;
      shadowGen.addShadowCaster(tower);

      const radarDome = BABYLON.MeshBuilder.CreateSphere('radarDome', { diameter: 18, segments: 10 }, scene);
      radarDome.position = new BABYLON.Vector3(-140, terrain.getHeightAtCoordinates(-140, -360) + 12, -360);
      const radarMat = new BABYLON.StandardMaterial('radarMat', scene);
      radarMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.95);
      radarDome.material = radarMat;
      radarDome.parent = baseRoot;
      shadowGen.addShadowCaster(radarDome);

      const rockMat = new BABYLON.StandardMaterial('rockMat', scene);
      rockMat.diffuseColor = new BABYLON.Color3(0.28, 0.26, 0.24);
      for (let i = 0; i < 25; i++) {
        const rock = BABYLON.MeshBuilder.CreateIcoSphere('rock-' + i, { radius: 4 + Math.random() * 3, subdivisions: 1 }, scene);
        rock.scaling = new BABYLON.Vector3(1, 0.6 + Math.random() * 0.4, 1);
        rock.position = new BABYLON.Vector3(Math.random() * 1400 - 700, 0, Math.random() * 1400 - 700);
        rock.position.y = terrain.getHeightAtCoordinates(rock.position.x, rock.position.z) + rock.scaling.y;
        rock.material = rockMat;
        rock.receiveShadows = true;
      }

      const jetRoot = new BABYLON.TransformNode('jetRoot', scene);
      const jetScale = 1.8;
      const fuselage = BABYLON.MeshBuilder.CreateCylinder('fuselage', { height: 12 * jetScale, diameterTop: 1.2 * jetScale, diameterBottom: 1.5 * jetScale, tessellation: 12 }, scene);
      fuselage.position = new BABYLON.Vector3(0, 0, 0);
      fuselage.rotation.x = Math.PI / 2;
      fuselage.parent = jetRoot;
      const nose = BABYLON.MeshBuilder.CreateCylinder('nose', { height: 2.5 * jetScale, diameterTop: 0, diameterBottom: 1.2 * jetScale, tessellation: 12 }, scene);
      nose.rotation.x = Math.PI / 2;
      nose.position = new BABYLON.Vector3(0, 6.8 * jetScale, 0);
      nose.parent = jetRoot;
      const cockpit = BABYLON.MeshBuilder.CreateSphere('cockpit', { diameter: 1.9 * jetScale, segments: 12 }, scene);
      cockpit.scaling = new BABYLON.Vector3(1.1, 0.7, 1);
      cockpit.position = new BABYLON.Vector3(0, 3.7 * jetScale, 0.2 * jetScale);
      cockpit.parent = jetRoot;
      const wing = BABYLON.MeshBuilder.CreateBox('wing', { width: 10 * jetScale, height: 0.2 * jetScale, depth: 2.6 * jetScale }, scene);
      wing.position = new BABYLON.Vector3(0, -0.3 * jetScale, 0);
      wing.rotation = new BABYLON.Vector3(0, 0, 0.08);
      wing.parent = jetRoot;
      const tail = BABYLON.MeshBuilder.CreateBox('tail', { width: 3 * jetScale, height: 0.2 * jetScale, depth: 2 * jetScale }, scene);
      tail.position = new BABYLON.Vector3(0, -5 * jetScale, 0);
      tail.parent = jetRoot;
      const tailfin = BABYLON.MeshBuilder.CreateBox('tailfin', { width: 0.2 * jetScale, height: 3.8 * jetScale, depth: 2 * jetScale }, scene);
      tailfin.position = new BABYLON.Vector3(0, -5.5 * jetScale, 0);
      tailfin.rotation.x = Math.PI / 15;
      tailfin.parent = jetRoot;
      const engineL = BABYLON.MeshBuilder.CreateCylinder('engineL', { height: 2 * jetScale, diameter: 1 * jetScale, tessellation: 12 }, scene);
      engineL.rotation.x = Math.PI / 2;
      engineL.position = new BABYLON.Vector3(-0.8 * jetScale, -5.8 * jetScale, 0);
      engineL.parent = jetRoot;
      const engineR = engineL.clone('engineR');
      engineR.position.x = 0.8 * jetScale;
      engineR.parent = jetRoot;
      const wingL = BABYLON.MeshBuilder.CreateBox('wingL', { width: 5 * jetScale, height: 0.2 * jetScale, depth: 2 * jetScale }, scene);
      wingL.position = new BABYLON.Vector3(-2.8 * jetScale, -0.5 * jetScale, 0);
      wingL.rotation.z = -0.35;
      wingL.parent = jetRoot;
      const wingR = wingL.clone('wingR');
      wingR.position.x = 2.8 * jetScale;
      wingR.rotation.z = 0.35;
      wingR.parent = jetRoot;
      const wingtipL = BABYLON.MeshBuilder.CreateBox('wingtipL', { width: 0.8 * jetScale, height: 0.15 * jetScale, depth: 1.1 * jetScale }, scene);
      wingtipL.position = new BABYLON.Vector3(-5.2 * jetScale, -0.4 * jetScale, 0);
      wingtipL.rotation.z = -0.4;
      wingtipL.parent = jetRoot;
      const wingtipR = wingtipL.clone('wingtipR');
      wingtipR.position.x = 5.2 * jetScale;
      wingtipR.rotation.z = 0.4;
      wingtipR.parent = jetRoot;

      const jetBodyMat = new BABYLON.PBRMetallicRoughnessMaterial('jetBodyMat', scene);
      jetBodyMat.baseColor = new BABYLON.Color3(0.25, 0.32, 0.38);
      jetBodyMat.metallic = 0.8;
      jetBodyMat.roughness = 0.35;
      [fuselage, nose, wing, tail, tailfin, wingL, wingR, wingtipL, wingtipR, engineL, engineR].forEach(m => m.material = jetBodyMat);

      const cockpitMat = new BABYLON.PBRMetallicRoughnessMaterial('cockpitMat', scene);
      cockpitMat.baseColor = new BABYLON.Color3(0.6, 0.8, 0.9);
      cockpitMat.metallic = 0.05;
      cockpitMat.roughness = 0.05;
      cockpitMat.alpha = 0.35;
      cockpit.material = cockpitMat;

      const exhaustMat = new BABYLON.StandardMaterial('exhaustMat', scene);
      exhaustMat.emissiveColor = new BABYLON.Color3(1, 0.4, 0.1);
      engineL.material = exhaustMat;
      engineR.material = exhaustMat;

      [fuselage, wing, tail, tailfin, wingL, wingR, wingtipL, wingtipR, nose, cockpit, engineL, engineR].forEach(m => shadowGen.addShadowCaster(m));

      const camPivot = new BABYLON.TransformNode('camPivot', scene);
      camPivot.position = new BABYLON.Vector3(0, 0, 0);
      const camera = new BABYLON.FreeCamera('pilotCam', new BABYLON.Vector3(0, 0, 0), scene);
      camera.inputs.clear();
      camera.fov = BABYLON.Tools.ToRadians(70);
      camera.minZ = 0.1;
      camera.maxZ = 10000;
      camera.inertia = 0.8;
      camera.parent = camPivot;
      camera.attachControl(canvas, true);

      const cameraRigState = {
        distanceBack: 11 * jetScale,
        height: 3.2 * jetScale,
        lateral: 0,
        targetDistance: 11 * jetScale,
        targetHeight: 3.2 * jetScale,
        targetLateral: 0,
        aimAmount: 0,
        fovBase: BABYLON.Tools.ToRadians(70),
        fovAim: BABYLON.Tools.ToRadians(45),
        fovMissile: BABYLON.Tools.ToRadians(82),
        missileZoom: 0,
        missileZoomDuration: 1.1,
        tmpPos: new BABYLON.Vector3(),
        tmpTarget: new BABYLON.Vector3(),
      };
      const cameraProfiles = {
        chase: { distanceBack: 11 * jetScale, height: 3.2 * jetScale, lateral: 0, fovBase: BABYLON.Tools.ToRadians(70), fovAim: BABYLON.Tools.ToRadians(48), label: 'Chase' },
        cockpit: { distanceBack: 2.2 * jetScale, height: 0.9 * jetScale, lateral: 0, fovBase: BABYLON.Tools.ToRadians(62), fovAim: BABYLON.Tools.ToRadians(45), label: 'Cockpit' },
        orbit: { distanceBack: 18 * jetScale, height: 6 * jetScale, lateral: 0.6 * jetScale, fovBase: BABYLON.Tools.ToRadians(80), fovAim: BABYLON.Tools.ToRadians(55), label: 'Orbit' }
      };
      function setCameraMode(mode) {
        const profile = cameraProfiles[mode];
        if (!profile) return;
        cameraRigState.targetDistance = profile.distanceBack;
        cameraRigState.targetHeight = profile.height;
        cameraRigState.targetLateral = profile.lateral;
        cameraRigState.fovBase = profile.fovBase;
        cameraRigState.fovAim = profile.fovAim;
        cameraModeButtons.forEach(btn => btn.classList.toggle('toggled', btn.dataset.cameraMode === mode));
        addLog('Camera mode set to ' + profile.label);
      }
      cameraModeButtons.forEach(btn => {
        btn.addEventListener('click', () => setCameraMode(btn.dataset.cameraMode));
      });
      setCameraMode('chase');

      const missileTemplate = BABYLON.MeshBuilder.CreateCylinder('missileTemplate', { height: 3.6, diameterTop: 0.18, diameterBottom: 0.45, tessellation: 12 }, scene);
      const missileCone = BABYLON.MeshBuilder.CreateCylinder('missileTip', { height: 1.1, diameterTop: 0, diameterBottom: 0.32, tessellation: 12 }, scene);
      missileCone.position.y = 2.1;
      missileCone.parent = missileTemplate;
      const missileTail = BABYLON.MeshBuilder.CreateSphere('missileTail', { diameter: 0.8, segments: 6 }, scene);
      missileTail.position.y = -1.8;
      missileTail.parent = missileTemplate;
      const missileFin = BABYLON.MeshBuilder.CreateBox('missileFin', { width: 0.12, height: 0.9, depth: 0.6 }, scene);
      missileFin.position = new BABYLON.Vector3(0, -1.2, 0.35);
      missileFin.parent = missileTemplate;
      const missileFinMirror = missileFin.clone('missileFinMirror');
      missileFinMirror.position.z = -0.35;
      const missileFinSide = missileFin.clone('missileFinSide');
      missileFinSide.rotation.y = Math.PI / 2;
      missileFinSide.position = new BABYLON.Vector3(0.35, -1.2, 0);
      const missileFinSideMirror = missileFinSide.clone('missileFinSideMirror');
      missileFinSideMirror.position.x = -0.35;
      const missileMat = new BABYLON.StandardMaterial('missileMat', scene);
      missileMat.diffuseColor = new BABYLON.Color3(0.88, 0.88, 0.92);
      missileMat.emissiveColor = new BABYLON.Color3(0.08, 0.08, 0.1);
      [missileTemplate, missileCone, missileTail, missileFin, missileFinMirror, missileFinSide, missileFinSideMirror].forEach(mesh => { mesh.material = missileMat; });
      missileTemplate.setEnabled(false);

      const targets = [];
      function spawnTarget(position) {
        const t = BABYLON.MeshBuilder.CreateBox('target', { size: 6 }, scene);
        t.position = position || new BABYLON.Vector3(Math.random() * 800 - 400, 200 + Math.random() * 200, Math.random() * 800 - 400);
        const tMat = new BABYLON.StandardMaterial('tMat-' + Math.random(), scene);
        tMat.diffuseColor = new BABYLON.Color3(0.9, 0.3, 0.3);
        tMat.emissiveColor = new BABYLON.Color3(0.4, 0.05, 0.05);
        t.material = tMat;
        shadowGen.addShadowCaster(t);
        targets.push({ mesh: t, alive: true });
        addLog('Target spawned at ' + t.position.toString());
      }
      for (let i = 0; i < 4; i++) { spawnTarget(); }

      const controls = {
        pitch: 0,
        roll: 0,
        yaw: 0,
        pitchInput: 0,
        rollInput: 0,
        yawInput: 0,
        throttle: 0.6,
        throttleTarget: 0.6,
        afterburner: false,
        masterArm: true,
      };

      function updateAssistButtons() {
        if (holdAltBtn) holdAltBtn.classList.toggle('toggled', autopilot.enabled && autopilot.lockAlt);
        if (holdHdgBtn) holdHdgBtn.classList.toggle('toggled', autopilot.enabled && autopilot.lockHdg);
        if (autopilotBtn) autopilotBtn.classList.toggle('toggled', autopilot.enabled);
      }

      function syncAssistUI() {
        if (altSlider && altLabel) {
          const feetAlt = Math.round(metersToFeet(autopilot.targetAlt));
          altSlider.value = feetAlt;
          altLabel.textContent = feetAlt + ' ft';
        }
        if (hdgSlider && hdgLabel) {
          const heading = ((autopilot.targetHdg % 360) + 360) % 360;
          hdgSlider.value = heading;
          hdgLabel.textContent = heading.toFixed(0) + '°';
        }
        updateAssistButtons();
        applyStatusBanner();
      }

      const input = { keys: {}, pointerLocked: false, aiming: false, crosshairX: 0, crosshairY: 0, crosshairRadius: 140 };
      updateCrosshairVisual({ x: input.crosshairX, y: input.crosshairY });
      window.addEventListener('keydown', (e) => {
        if (e.code === 'KeyH') {
          toggleFocusMode();
          return;
        }
        input.keys[e.code] = true;
        if (e.code === 'Digit1') ui.modePill.textContent = 'NAV MODE';
        if (e.code === 'Digit2') ui.modePill.textContent = 'WPN MODE';
        if (e.code === 'KeyF') controls.afterburner = !controls.afterburner;
        if (e.code === 'KeyG') toggleGear();
        if (e.code === 'Space') fireMissile();
        if (e.code === 'KeyR') resetAttitude();
      });
      window.addEventListener('keyup', (e) => { input.keys[e.code] = false; });
      canvas.addEventListener('click', () => {
        if (!input.pointerLocked) canvas.requestPointerLock();
        fireMissile();
      });
      document.addEventListener('pointerlockchange', () => {
        input.pointerLocked = !!document.pointerLockElement;
        if (!input.pointerLocked) {
          input.aiming = false;
          input.crosshairX = 0;
          input.crosshairY = 0;
          updateCrosshairVisual({ x: 0, y: 0 });
        }
      });
      document.addEventListener('mousemove', (e) => {
        if (!input.pointerLocked) return;
        const sensitivity = 0.8;
        input.crosshairX = clamp(input.crosshairX + e.movementX * sensitivity, -input.crosshairRadius, input.crosshairRadius);
        input.crosshairY = clamp(input.crosshairY + e.movementY * sensitivity, -input.crosshairRadius, input.crosshairRadius);
        updateCrosshairVisual({ x: input.crosshairX, y: input.crosshairY });
      });
      document.addEventListener('mousedown', (e) => {
        if (e.button === 2) {
          input.aiming = true;
          e.preventDefault();
        }
      });
      document.addEventListener('mouseup', (e) => {
        if (e.button === 2) {
          input.aiming = false;
          e.preventDefault();
        }
      });
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());

      const masterArmBtn = document.getElementById('btn-master-arm');
      const afterburnBtn = document.getElementById('btn-afterburn');
      const resetViewBtn = document.getElementById('btn-reset-view');
      const spawnTargetBtn = document.getElementById('btn-spawn-target');
      const clearMissilesBtn = document.getElementById('btn-clear-missiles');

      if (masterArmBtn) masterArmBtn.onclick = () => toggleMasterArm();
      if (afterburnBtn) afterburnBtn.onclick = () => { controls.afterburner = !controls.afterburner; };
      if (autopilotBtn) autopilotBtn.onclick = () => {
        autopilot.enabled = !autopilot.enabled;
        if (!autopilot.enabled) {
          autopilot.lockAlt = false;
          autopilot.lockHdg = false;
        }
        addLog('Autopilot ' + (autopilot.enabled ? 'enabled' : 'disabled'));
        syncAssistUI();
      };
      if (resetViewBtn) resetViewBtn.onclick = () => resetAttitude();
      if (spawnTargetBtn) spawnTargetBtn.onclick = () => spawnTarget();
      if (clearMissilesBtn) clearMissilesBtn.onclick = () => {
        missiles.forEach(m => {
          m.mesh.dispose();
          m.alive = false;
        });
        missiles.length = 0;
      };

      const gear = { down: false };
      function toggleGear() {
        gear.down = !gear.down;
        document.getElementById('tile-gear').textContent = gear.down ? 'DOWN' : 'UP';
        addLog('Gear ' + (gear.down ? 'deployed' : 'retracted'));
      }

      function toggleMasterArm() {
        controls.masterArm = !controls.masterArm;
        ui.weaponPill.textContent = controls.masterArm ? 'ARMED' : 'SAFE';
        tileMasterArm.textContent = controls.masterArm ? 'ARMED' : 'SAFE';
        addLog('Master arm ' + (controls.masterArm ? 'on' : 'off'));
      }

      const jetState = {
        position: new BABYLON.Vector3(0, 400, 0),
        velocity: new BABYLON.Vector3(0, 0, 120),
        orientation: BABYLON.Quaternion.Identity(),
        angularVelocity: new BABYLON.Vector3(0, 0, 0),
        mass: 14500,
        fuel: 100,
      };
      autopilot.targetAlt = jetState.position.y;
      autopilot.targetHdg = 0;
      syncAssistUI();

      if (altSlider) altSlider.addEventListener('input', (event) => {
        autopilot.targetAlt = feetToMeters(parseFloat(event.target.value));
        syncAssistUI();
      });
      if (hdgSlider) hdgSlider.addEventListener('input', (event) => {
        autopilot.targetHdg = parseFloat(event.target.value);
        syncAssistUI();
      });
      if (holdAltBtn) holdAltBtn.addEventListener('click', () => {
        autopilot.lockAlt = !autopilot.lockAlt;
        if (autopilot.lockAlt) autopilot.enabled = true;
        addLog('Altitude hold ' + (autopilot.lockAlt ? 'armed' : 'released'));
        syncAssistUI();
      });
      if (holdHdgBtn) holdHdgBtn.addEventListener('click', () => {
        autopilot.lockHdg = !autopilot.lockHdg;
        if (autopilot.lockHdg) autopilot.enabled = true;
        addLog('Heading hold ' + (autopilot.lockHdg ? 'armed' : 'released'));
        syncAssistUI();
      });

      camPivot.rotationQuaternion = BABYLON.Quaternion.Identity();

      const missiles = [];
      let missileLaunchIndex = 0;

      function spawnExplosion(position, magnitude = 1) {
        const impactPos = position.clone ? position.clone() : new BABYLON.Vector3(position.x, position.y, position.z);
        const flash = BABYLON.MeshBuilder.CreateSphere('explosionFlash-' + Math.random(), { diameter: 3 + magnitude * 2.2, segments: 10 }, scene);
        const flashMat = new BABYLON.StandardMaterial('flashMat-' + Math.random(), scene);
        flashMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.45);
        flashMat.alpha = 0.95;
        flash.material = flashMat;
        flash.position.copyFrom(impactPos);
        let flashLife = 0.35 + 0.2 * magnitude;
        const flashObserver = scene.onBeforeRenderObservable.add(() => {
          const dt = engine.getDeltaTime() / 1000;
          flashLife -= dt;
          const expansion = 18 * magnitude * dt;
          flash.scaling.addInPlace(new BABYLON.Vector3(expansion, expansion, expansion));
          flashMat.alpha = Math.max(0, flashLife * 1.8);
          if (flashLife <= 0) {
            flash.dispose();
            scene.onBeforeRenderObservable.remove(flashObserver);
          }
        });

        const shockwave = BABYLON.MeshBuilder.CreateDisc('shockwave-' + Math.random(), { radius: 1.4, tessellation: 48 }, scene);
        shockwave.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
        const shockMat = new BABYLON.StandardMaterial('shockMat-' + Math.random(), scene);
        shockMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.2);
        shockMat.alpha = 0.85;
        shockMat.backFaceCulling = false;
        shockwave.material = shockMat;
        shockwave.position.copyFrom(impactPos);
        let shockLife = 0.55 + 0.2 * magnitude;
        const shockObserver = scene.onBeforeRenderObservable.add(() => {
          const dt = engine.getDeltaTime() / 1000;
          shockLife -= dt;
          const progress = 1 - Math.max(shockLife, 0) / (0.55 + 0.2 * magnitude);
          shockwave.scaling.setAll(1 + progress * 12 * magnitude);
          shockMat.alpha = Math.max(0, 0.85 - progress);
          if (shockLife <= 0) {
            shockwave.dispose();
            scene.onBeforeRenderObservable.remove(shockObserver);
          }
        });

        const explosion = new BABYLON.ParticleSystem('missileExplosion-' + Math.random(), Math.floor(420 * magnitude), scene);
        explosion.particleTexture = explosionTexture;
        explosion.emitter = impactPos;
        explosion.minEmitPower = 30 * magnitude;
        explosion.maxEmitPower = 95 * magnitude;
        explosion.minLifeTime = 0.25;
        explosion.maxLifeTime = 0.65;
        explosion.minSize = 1.6 * magnitude;
        explosion.maxSize = 5.6 * magnitude;
        explosion.direction1 = new BABYLON.Vector3(-1, -1, -1);
        explosion.direction2 = new BABYLON.Vector3(1, 1, 1);
        explosion.gravity = new BABYLON.Vector3(0, -14, 0);
        explosion.emitRate = 0;
        explosion.disposeOnStop = true;
        explosion.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
        explosion.manualEmitCount = Math.floor(360 * magnitude);
        explosion.start();
        setTimeout(() => explosion.stop(), 280);
      }

      function spawnBoomText(position, label = 'BOOM') {
        if (!scene) return;
        const anchor = position.clone ? position.clone() : new BABYLON.Vector3(position.x, position.y, position.z);
        const plane = BABYLON.MeshBuilder.CreatePlane('impactText-' + Math.random(), { width: 6, height: 2.4 }, scene);
        plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
        plane.position.copyFrom(anchor);
        plane.position.y += 3;
        const tex = new BABYLON.DynamicTexture('impactTextTex-' + Math.random(), { width: 512, height: 256 }, scene, true);
        const ctx = tex.getContext();
        ctx.clearRect(0, 0, 512, 256);
        ctx.font = 'bold 120px Rajdhani';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = '#ff9c3a';
        ctx.lineWidth = 12;
        ctx.fillStyle = '#ffffff';
        ctx.strokeText(label, 256, 132);
        ctx.fillText(label, 256, 132);
        tex.update();
        const mat = new BABYLON.StandardMaterial('impactTextMat-' + Math.random(), scene);
        mat.diffuseTexture = tex;
        mat.opacityTexture = tex;
        mat.emissiveColor = new BABYLON.Color3(1, 0.55, 0.25);
        mat.backFaceCulling = false;
        mat.alpha = 1;
        plane.material = mat;
        let life = 1.2;
        const observer = scene.onBeforeRenderObservable.add(() => {
          const dt = engine.getDeltaTime() / 1000;
          life -= dt;
          const progress = 1 - Math.max(life, 0) / 1.2;
          plane.position.y += dt * 6;
          plane.scaling.setAll(1 + progress * 0.4);
          mat.alpha = Math.max(0, 1 - progress);
          if (life <= 0) {
            plane.dispose();
            scene.onBeforeRenderObservable.remove(observer);
          }
        });
      }

      function vaporizeTarget(target) {
        if (!target || !target.mesh) return;
        const mesh = target.mesh;
        const startScale = mesh.scaling.clone();
        let mat;
        if (mesh.material && mesh.material.clone) {
          mat = mesh.material.clone('targetVaporMat-' + Math.random());
        } else {
          mat = new BABYLON.StandardMaterial('targetVaporMat-' + Math.random(), scene);
        }
        mat.alpha = 1;
        mat.emissiveColor = new BABYLON.Color3(1, 0.65, 0.25);
        mesh.material = mat;
        let life = 0.85;
        const vaporObserver = scene.onBeforeRenderObservable.add(() => {
          const dt = engine.getDeltaTime() / 1000;
          life -= dt;
          const progress = 1 - Math.max(life, 0) / 0.85;
          const expand = 1 + progress * 0.65;
          mesh.scaling.set(startScale.x * expand, startScale.y * Math.max(0.2, 1 - progress * 0.85), startScale.z * expand);
          mat.alpha = Math.max(0, 1 - progress);
          mat.emissiveColor = BABYLON.Color3.Lerp(new BABYLON.Color3(1, 0.85, 0.4), new BABYLON.Color3(1, 0.2, 0.05), progress);
          if (life <= 0) {
            mesh.dispose();
            if (target) target.mesh = null;
            scene.onBeforeRenderObservable.remove(vaporObserver);
          }
        });
      }

      function handleMissileImpact(missile, message, options = {}) {
        if (!missile.alive) return;
        const impactPos = options.impactPosition ? options.impactPosition.clone() : (missile.solver ? missile.solver.state.position.clone() : BABYLON.Vector3.Zero());
        spawnExplosion(impactPos, options.explosionScale || 1);
        if (options.boomText) {
          spawnBoomText(impactPos.clone(), options.boomText);
        }
        missile.alive = false;
        missile.mesh.dispose();
        cameraRigState.missileZoom = Math.max(cameraRigState.missileZoom, cameraRigState.missileZoomDuration * 0.5);
        if (message) addLog(message);
      }

      function forwardVector() { return new BABYLON.Vector3(0, 1, 0).rotateByQuaternionToRef(jetState.orientation, new BABYLON.Vector3()); }
      function rightVector() { return new BABYLON.Vector3(1, 0, 0).rotateByQuaternionToRef(jetState.orientation, new BABYLON.Vector3()); }
      function upVector() { return new BABYLON.Vector3(0, 0, 1).rotateByQuaternionToRef(jetState.orientation, new BABYLON.Vector3()); }
      if (matchFlightBtn) matchFlightBtn.addEventListener('click', () => {
        autopilot.targetAlt = jetState.position.y;
        const heading = ((Math.atan2(forwardVector().x, forwardVector().z) * 180 / Math.PI) + 360) % 360;
        autopilot.targetHdg = heading;
        addLog('Pilot assist synced to current flight path');
        syncAssistUI();
      });
      function crosshairDirection() {
        const width = engine.getRenderWidth(true);
        const height = engine.getRenderHeight(true);
        const screenX = width * 0.5 + input.crosshairX;
        const screenY = height * 0.5 + input.crosshairY;
        const world = BABYLON.Matrix.Identity();
        const origin = BABYLON.Vector3.Unproject(new BABYLON.Vector3(screenX, screenY, 0), width, height, world, camera.getViewMatrix(), camera.getProjectionMatrix());
        const target = BABYLON.Vector3.Unproject(new BABYLON.Vector3(screenX, screenY, 1), width, height, world, camera.getViewMatrix(), camera.getProjectionMatrix());
        return target.subtract(origin).normalize();
      }

      function updateInputs(dt) {
        const keyboardPitch = (input.keys['KeyS'] ? 1 : 0) - (input.keys['KeyW'] ? 1 : 0);
        const keyboardRoll = (input.keys['KeyD'] ? 1 : 0) - (input.keys['KeyA'] ? 1 : 0);
        const keyboardYaw = (input.keys['KeyE'] ? 1 : 0) - (input.keys['KeyQ'] ? 1 : 0);
        const targetPitch = clamp(keyboardPitch * 0.8, -0.9, 0.9);
        const targetRoll = clamp(keyboardRoll * 0.9, -0.9, 0.9);
        const targetYaw = clamp(keyboardYaw * 0.6, -0.6, 0.6);
        const response = 1 - Math.exp(-dt * 10);
        controls.pitchInput += (targetPitch - controls.pitchInput) * response;
        controls.rollInput += (targetRoll - controls.rollInput) * response;
        controls.yawInput += (targetYaw - controls.yawInput) * response;
        if (input.keys['ShiftLeft']) controls.throttleTarget += dt * 0.4;
        if (input.keys['ControlLeft']) controls.throttleTarget -= dt * 0.4;
        controls.throttleTarget = clamp(controls.throttleTarget, 0, 1.1);
        const throttleResponse = 1 - Math.exp(-dt * 3);
        controls.throttle += (controls.throttleTarget - controls.throttle) * throttleResponse;
      }

      function atmosphereDensity(alt) {
        const rho0 = 1.225;
        const h = Math.max(0, alt);
        return rho0 * Math.exp(-h / 8500);
      }

      function computeAerodynamics(state) {
        const fwd = forwardVector();
        const up = upVector();
        const vel = state.velocity;
        const speed = vel.length();
        if (speed < 0.1) return { lift: BABYLON.Vector3.Zero(), drag: BABYLON.Vector3.Zero(), aoa: 0 };
        const vDir = vel.normalizeToNew();
        const aoa = BABYLON.Vector3.Dot(vDir, fwd);
        const alpha = Math.acos(clamp(aoa, -1, 1));
        const aoaSigned = BABYLON.Vector3.Dot(vel, up) >= 0 ? alpha : -alpha;
        const rho = atmosphereDensity(state.position.y);
        const wingArea = 38;
        const clAlpha = 5.5;
        const cl = clamp(clAlpha * aoaSigned, -1.8, 1.8);
        const liftMag = 0.5 * rho * speed * speed * wingArea * cl;
        const liftDir = BABYLON.Vector3.Cross(vDir, rightVector()).normalizeToNew();
        const dragCd0 = 0.02;
        const dragCd = dragCd0 + Math.abs(cl) * 0.02 + controls.afterburner * 0.01;
        const dragMag = 0.5 * rho * speed * speed * wingArea * dragCd;
        const drag = vDir.scale(-dragMag);
        const lift = liftDir.scale(liftMag);
        return { lift, drag, aoa: aoaSigned };
      }

      function computeThrust() {
        const base = controls.afterburner ? 160000 : 110000;
        return base * controls.throttle;
      }

      function computeTorques(alpha, state) {
        const angVel = state.angularVelocity;
        const pitchTorque = controls.pitch * 65000 - alpha * 18000 - angVel.z * 32000;
        const rollTorque = controls.roll * 90000 - angVel.x * 36000;
        const yawTorque = controls.yaw * 45000 - angVel.y * 22000;
        return new BABYLON.Vector3(rollTorque, yawTorque, pitchTorque);
      }

      function integrate(state, dt) {
        const g = new BABYLON.Vector3(0, -9.81, 0);
        const aero = computeAerodynamics(state);
        const thrustMag = computeThrust();
        const thrust = forwardVector().scale(thrustMag);
        const weight = g.scale(state.mass);
        const totalForce = thrust.add(aero.lift).add(aero.drag).add(weight);
        const acc = totalForce.scale(1 / state.mass);
        state.velocity.addInPlace(acc.scale(dt));
        state.position.addInPlace(state.velocity.scale(dt));
        const torques = computeTorques(aero.aoa, state);
        const angAcc = torques.scale(1 / (state.mass * 0.2));
        state.angularVelocity.addInPlace(angAcc.scale(dt));
        const angVelQuat = new BABYLON.Quaternion(state.angularVelocity.x * dt * 0.5, state.angularVelocity.y * dt * 0.5, state.angularVelocity.z * dt * 0.5, 0);
        state.orientation = state.orientation.add(state.orientation.multiply(angVelQuat));
        state.orientation.normalize();
        const angDamp = Math.max(0, 1 - dt * 1.2);
        state.angularVelocity.scaleInPlace(angDamp);
        if (state.position.y < terrain.getHeightAtCoordinates(state.position.x, state.position.z) + 5) {
          state.position.y = terrain.getHeightAtCoordinates(state.position.x, state.position.z) + 5;
          state.velocity.y = Math.max(0, state.velocity.y * -0.2);
        }
      }

      function resetAttitude() {
        jetState.orientation = BABYLON.Quaternion.Identity();
        jetState.angularVelocity = BABYLON.Vector3.Zero();
        addLog('Attitude reset');
      }

      function spawnMissileMesh() {
        const m = missileTemplate.clone('missile-' + Math.random());
        m.setEnabled(true);
        m.position = BABYLON.Vector3.Zero();
        m.rotation = BABYLON.Vector3.Zero();
        shadowGen.addShadowCaster(m);
        return m;
      }

      function fireMissile() {
        if (!controls.masterArm) { addLog('Cannot fire: MASTER ARM SAFE'); return; }
        const mesh = spawnMissileMesh();
        const right = rightVector();
        const up = upVector();
        const aimDir = crosshairDirection();
        const railSide = missileLaunchIndex % 2 === 0 ? 1 : -1;
        missileLaunchIndex += 1;
        const muzzleForward = aimDir.clone().scale(2.5);
        const offset = right.scale(railSide * 1.2).add(up.scale(-0.8)).add(muzzleForward);
        const spawnPosition = jetState.position.add(offset);
        mesh.position.copyFrom(spawnPosition);
        mesh.lookAt(mesh.position.add(aimDir.clone()));
        const initialVelocity = jetState.velocity.clone().add(aimDir.clone().scale(220));
        const solver = new ProjectilePhysicsEngine({
          mass: 85,
          area: Math.PI * Math.pow(0.15, 2),
          dragCoefficient: 0.42,
          gravity: 9.81,
          airDensity: 1.225,
          dragModel: 'quadratic',
          integrator: 'rk4',
          variableGravity: true,
          variableDensity: true,
          scaleHeight: 8500,
          windVector: new BABYLON.Vector3()
        }, {
          position: mesh.position.clone(),
          velocity: initialVelocity
        });
        const state = {
          solver,
          alive: true,
          time: 0,
          mesh
        };
        missiles.push(state);
        cameraRigState.missileZoom = cameraRigState.missileZoomDuration;
        ui.badgeMissiles.textContent = 'MISSILES: ∞';
        addLog('Missile away');
      }

      function stepMissile(m, dt) {
        if (!m.alive) return;
        m.solver.step(dt);
        m.time += dt;
        const pos = m.solver.state.position;
        const vel = m.solver.state.velocity;
        m.mesh.position.copyFrom(pos);
        if (vel.lengthSquared() > 0.001) {
          const lookTarget = pos.add(vel.normalizeToNew());
          m.mesh.lookAt(lookTarget);
        }
        const groundHeight = terrain.getHeightAtCoordinates(pos.x, pos.z) + 2;
        if (pos.y <= groundHeight) {
          handleMissileImpact(m, 'Missile impact', { explosionScale: 1.25 });
          return;
        }
        if (m.time > 24) {
          m.alive = false;
          m.mesh.dispose();
          return;
        }
        for (let i = 0; i < targets.length; i++) {
          if (!m.alive) break;
          const t = targets[i];
          if (t.alive && BABYLON.Vector3.DistanceSquared(t.mesh.position, pos) < 49) {
            t.alive = false;
            const impactPos = t.mesh.position.clone();
            vaporizeTarget(t);
            handleMissileImpact(m, 'Target vaporized', { impactPosition: impactPos, explosionScale: 1.6, boomText: 'BOOM' });
          }
        }
      }

      function updateCameraRig(dt) {
        const rigResponse = 1 - Math.exp(-dt * 3);
        cameraRigState.distanceBack += (cameraRigState.targetDistance - cameraRigState.distanceBack) * rigResponse;
        cameraRigState.height += (cameraRigState.targetHeight - cameraRigState.height) * rigResponse;
        cameraRigState.lateral += (cameraRigState.targetLateral - cameraRigState.lateral) * rigResponse;
        const aimTarget = input.aiming ? 1 : 0;
        cameraRigState.aimAmount += (aimTarget - cameraRigState.aimAmount) * (1 - Math.exp(-dt * 8));
        if (cameraRigState.missileZoom > 0) {
          cameraRigState.missileZoom = Math.max(0, cameraRigState.missileZoom - dt);
        }

        const backOffset = forwardVector().scale(-cameraRigState.distanceBack);
        const upOffset = upVector().scale(cameraRigState.height);
        const lateralOffset = rightVector().scale(cameraRigState.lateral);
        cameraRigState.tmpPos.copyFrom(jetState.position);
        cameraRigState.tmpPos.addInPlace(backOffset);
        cameraRigState.tmpPos.addInPlace(upOffset);
        cameraRigState.tmpPos.addInPlace(lateralOffset);
        camPivot.position.copyFrom(cameraRigState.tmpPos);
        if (!camPivot.rotationQuaternion) {
          camPivot.rotationQuaternion = BABYLON.Quaternion.Identity();
        }
        camPivot.rotationQuaternion.copyFrom(jetState.orientation);

        cameraRigState.tmpTarget.copyFrom(jetState.position);
        cameraRigState.tmpTarget.addInPlace(forwardVector().scale(50));
        cameraRigState.tmpTarget.addInPlace(upVector().scale(2.5 * jetScale));
        camera.setTarget(cameraRigState.tmpTarget);

        let targetFov = cameraRigState.fovBase;
        targetFov = BABYLON.Scalar.Lerp(targetFov, cameraRigState.fovAim, cameraRigState.aimAmount);
        if (cameraRigState.missileZoom > 0) {
          const missileBlend = cameraRigState.missileZoom / cameraRigState.missileZoomDuration;
          targetFov = BABYLON.Scalar.Lerp(targetFov, cameraRigState.fovMissile, missileBlend);
        }
        camera.fov = BABYLON.Scalar.Lerp(camera.fov, targetFov, 1 - Math.exp(-dt * 6));
      }

      function updateTacticalMap(dt = 0) {
        if (!tacticalCtx || !tacticalCanvas) return;
        const width = tacticalCanvas.width;
        const height = tacticalCanvas.height;
        if (width === 0 || height === 0) return;
        const centerX = width / 2;
        const centerY = height / 2;
        const mapRadius = Math.min(centerX, centerY) - 12;
        if (mapRadius <= 0) return;
        const pxPerMeter = mapRadius / tacticalMapState.boundary;
        tacticalMapState.pulse = (tacticalMapState.pulse + dt * 0.7) % 1;

        const bg = tacticalCtx.createLinearGradient(0, 0, 0, height);
        bg.addColorStop(0, 'rgba(4, 9, 16, 0.96)');
        bg.addColorStop(1, 'rgba(3, 6, 12, 0.9)');
        tacticalCtx.fillStyle = bg;
        tacticalCtx.fillRect(0, 0, width, height);

        const gridSpacing = 32;
        tacticalCtx.strokeStyle = 'rgba(57, 210, 255, 0.08)';
        tacticalCtx.lineWidth = 1;
        for (let x = 0; x <= width; x += gridSpacing) {
          tacticalCtx.beginPath();
          tacticalCtx.moveTo(x + 0.5, 0);
          tacticalCtx.lineTo(x + 0.5, height);
          tacticalCtx.stroke();
        }
        for (let y = 0; y <= height; y += gridSpacing) {
          tacticalCtx.beginPath();
          tacticalCtx.moveTo(0, y + 0.5);
          tacticalCtx.lineTo(width, y + 0.5);
          tacticalCtx.stroke();
        }

        tacticalCtx.strokeStyle = 'rgba(57, 210, 255, 0.25)';
        tacticalCtx.setLineDash([6, 6]);
        tacticalCtx.beginPath();
        tacticalCtx.arc(centerX, centerY, mapRadius, 0, Math.PI * 2);
        tacticalCtx.stroke();
        tacticalCtx.setLineDash([]);

        const pulseAlpha = Math.max(0, 0.35 - tacticalMapState.pulse * 0.3);
        const pulseRadius = mapRadius * (0.2 + tacticalMapState.pulse * 0.8);
        tacticalCtx.strokeStyle = 'rgba(87, 247, 158, ' + pulseAlpha + ')';
        tacticalCtx.beginPath();
        tacticalCtx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
        tacticalCtx.stroke();

        tacticalCtx.strokeStyle = 'rgba(57, 210, 255, 0.18)';
        tacticalCtx.beginPath();
        tacticalCtx.moveTo(centerX, centerY - mapRadius);
        tacticalCtx.lineTo(centerX, centerY + mapRadius);
        tacticalCtx.moveTo(centerX - mapRadius, centerY);
        tacticalCtx.lineTo(centerX + mapRadius, centerY);
        tacticalCtx.stroke();

        const projectPoint = (worldVec) => {
          const dx = worldVec.x - jetState.position.x;
          const dz = worldVec.z - jetState.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          const capped = distance > tacticalMapState.boundary ? tacticalMapState.boundary : distance;
          const scale = distance === 0 ? 0 : capped / distance;
          return {
            x: centerX + dx * pxPerMeter * scale,
            y: centerY + dz * pxPerMeter * scale,
            clamped: distance > tacticalMapState.boundary
          };
        };

        const heading = Math.atan2(forwardVector().x, forwardVector().z);
        tacticalCtx.save();
        tacticalCtx.translate(centerX, centerY);
        tacticalCtx.rotate(-heading);
        tacticalCtx.fillStyle = 'rgba(57, 210, 255, 0.95)';
        tacticalCtx.beginPath();
        tacticalCtx.moveTo(0, -14);
        tacticalCtx.lineTo(9, 10);
        tacticalCtx.lineTo(-9, 10);
        tacticalCtx.closePath();
        tacticalCtx.fill();
        tacticalCtx.restore();

        missiles.forEach((missile) => {
          if (!missile.alive || !missile.solver) return;
          const projected = projectPoint(missile.solver.state.position);
          tacticalCtx.beginPath();
          tacticalCtx.fillStyle = projected.clamped ? 'rgba(255, 179, 71, 0.45)' : 'rgba(255, 179, 71, 0.95)';
          tacticalCtx.arc(projected.x, projected.y, projected.clamped ? 3 : 4.5, 0, Math.PI * 2);
          tacticalCtx.fill();
          const vel = missile.solver.state.velocity;
          const velScale = pxPerMeter * 0.25;
          tacticalCtx.strokeStyle = 'rgba(255, 179, 71, 0.6)';
          tacticalCtx.beginPath();
          tacticalCtx.moveTo(projected.x, projected.y);
          tacticalCtx.lineTo(projected.x + vel.x * velScale, projected.y + vel.z * velScale);
          tacticalCtx.stroke();
        });
      }

      function updateHUD(dt) {
        ui.hudThrottle.textContent = Math.round(controls.throttle * 100) + '%';
        ui.hudSpeed.textContent = Math.round(jetState.velocity.length() * 1.94384) + ' kts';
        ui.hudAltitude.textContent = Math.round(jetState.position.y * 3.28084) + ' ft';
        const fwd = forwardVector();
        const heading = Math.atan2(fwd.x, fwd.z) * 180 / Math.PI;
        ui.hudHeading.textContent = ((heading + 360) % 360).toFixed(0) + '°';
        const pitchAngle = Math.asin(fwd.y) * 180 / Math.PI;
        ui.hudPitch.textContent = pitchAngle.toFixed(1) + '°';
        const rollVec = rightVector();
        const rollAngle = Math.atan2(rollVec.y, rollVec.x) * 180 / Math.PI;
        ui.hudRoll.textContent = rollAngle.toFixed(1) + '°';
        document.getElementById('tile-throttle').textContent = ui.hudThrottle.textContent;
        document.getElementById('bar-throttle').style.width = Math.min(100, controls.throttle * 100) + '%';
        document.getElementById('tile-pitch').textContent = ui.hudPitch.textContent;
        document.getElementById('tile-roll').textContent = ui.hudRoll.textContent;
        document.getElementById('tile-yaw').textContent = (controls.yaw * 45).toFixed(0) + '°/s';
        document.getElementById('tile-fuel').textContent = jetState.fuel.toFixed(0) + '%';
        document.getElementById('bar-fuel').style.width = jetState.fuel + '%';
        document.getElementById('tile-afterburn').textContent = controls.afterburner ? 'ON' : 'OFF';
        const modeLabel = autopilot.enabled ? (autopilot.lockAlt && autopilot.lockHdg ? 'AP HOLD' : autopilot.lockAlt ? 'ALT HOLD' : autopilot.lockHdg ? 'HDG HOLD' : 'ASSIST') : 'MANUAL';
        document.getElementById('tile-flight-mode').textContent = modeLabel;
        ui.badgeTargets.textContent = 'TARGETS: ' + targets.filter(t => t.alive).length;
      }

      function animateIndicators(dt) {
        const r = () => Math.random();
        document.getElementById('bar-radar').style.width = (60 + r() * 20) + '%';
        document.getElementById('tile-radar').textContent = r() > 0.5 ? 'SWEEP' : 'TRACK';
        document.getElementById('tile-aoa').textContent = (computeAerodynamics(jetState).aoa * 57.3).toFixed(1) + '°';
        document.getElementById('dial-aoa').style.width = (Math.abs(computeAerodynamics(jetState).aoa) * 120).toFixed(1) + '%';
        document.getElementById('tile-icing').textContent = jetState.position.y > 8000 ? 'WATCH' : 'CLEAR';
      }

      function step(dt) {
        updateInputs(dt);
        if (autopilot.enabled) {
          if (autopilot.lockHdg) {
            const headingError = ((autopilot.targetHdg - Math.atan2(forwardVector().x, forwardVector().z) * 180 / Math.PI + 540) % 360) - 180;
            controls.yawInput = clamp(headingError / 60, -0.4, 0.4);
            controls.rollInput = clamp(-headingError / 90, -0.5, 0.5);
          }
          if (autopilot.lockAlt) {
            const altError = (autopilot.targetAlt - jetState.position.y);
            controls.pitchInput = clamp(-altError / 800, -0.45, 0.45);
          }
        }
        const controlBlend = 1 - Math.exp(-dt * 6);
        controls.pitch += (controls.pitchInput - controls.pitch) * controlBlend;
        controls.roll += (controls.rollInput - controls.roll) * controlBlend;
        controls.yaw += (controls.yawInput - controls.yaw) * controlBlend;
        integrate(jetState, dt);
        jetRoot.position.copyFrom(jetState.position);
        jetRoot.rotationQuaternion = jetState.orientation;
        missiles.forEach(m => stepMissile(m, dt));
        for (let i = missiles.length - 1; i >= 0; i--) if (!missiles[i].alive) missiles.splice(i, 1);
        updateCameraRig(dt);
        animateIndicators(dt);
        updateHUD(dt);
        updateTacticalMap(dt);
      }

      let last = performance.now();
      engine.runRenderLoop(() => {
        const now = performance.now();
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        step(dt);
        ui.badgeFps.textContent = 'FPS: ' + engine.getFps().toFixed(0);
        scene.render();
      });

      window.addEventListener('resize', () => engine.resize());
      addLog('Simulation initialized');
      return scene;
    }

    const scene = createScene();
  </script>
</body>
</html>
