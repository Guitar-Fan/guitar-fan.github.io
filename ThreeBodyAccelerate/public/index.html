<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå Three-Body Problem - Interactive Physics Simulation</title>
    <meta name="description" content="Explore the classical three-body problem with interactive physics simulation. Create periodic orbits, observe chaos, and watch gravitational dynamics in real-time!">
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            color: #e8e8e8;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            gap: 0;
            min-height: 100vh;
        }
        
        #sidebar {
            width: 300px;
            background: rgba(22, 22, 35, 0.95);
            border-right: 1px solid rgba(100, 100, 120, 0.2);
            padding: 20px;
            overflow-y: auto;
            max-height: 100vh;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        
        #mainContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 1px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            background-size: 200% 200%;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        h2 {
            font-size: 13px;
            font-weight: 600;
            margin: 25px 0 12px 0;
            color: #9d9db0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(100, 100, 120, 0.15);
            padding-bottom: 8px;
        }
        
        #canvasContainer {
            position: relative;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        canvas {
            display: block;
            background: #000000;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 6px;
            color: #b0b0c0;
            font-weight: 500;
        }
        
        button {
            width: 100%;
            background: linear-gradient(180deg, #2a2a3e 0%, #1f1f2e 100%);
            border: 1px solid rgba(100, 100, 120, 0.3);
            color: #e0e0f0;
            padding: 10px 14px;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s ease;
            margin: 4px 0;
            border-radius: 3px;
            font-weight: 500;
        }
        
        button:hover {
            background: linear-gradient(180deg, #353550 0%, #2a2a40 100%);
            border-color: rgba(120, 120, 150, 0.5);
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
            background: linear-gradient(180deg, #1f1f2e 0%, #1a1a28 100%);
        }
        
        button.primary {
            background: linear-gradient(180deg, #4a5568 0%, #3a4556 100%);
            border-color: rgba(140, 140, 160, 0.4);
        }
        
        button.primary:hover {
            background: linear-gradient(180deg, #5a6578 0%, #4a5568 100%);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(100, 100, 120, 0.2);
            border-radius: 2px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #7a7a9a;
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #9a9aba;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #7a7a9a;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .value-display {
            color: #8a8aa5;
            font-size: 12px;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
        }
        
        #stats {
            background: rgba(30, 30, 45, 0.6);
            border: 1px solid rgba(100, 100, 120, 0.15);
            border-radius: 4px;
            padding: 12px;
            margin: 15px 0;
            font-size: 12px;
            width: 100%;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 4px 0;
        }
        
        .stat-label {
            color: #8a8aa5;
            font-weight: 500;
        }
        
        .stat-value {
            color: #d0d0e5;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        #loading {
            font-size: 16px;
            text-align: center;
            padding: 40px;
            color: #b0b0c0;
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }
        
        .preset-grid button {
            font-size: 12px;
            padding: 8px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
            cursor: pointer;
            user-select: none;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #6a6a8a;
        }
        
        .checkbox-container label {
            margin: 0;
            flex: 1;
            cursor: pointer;
            color: #b0b0c0;
        }
        
        #physicsInfo {
            background: rgba(20, 20, 30, 0.5);
            border: 1px solid rgba(100, 100, 120, 0.1);
            border-radius: 4px;
            padding: 12px;
            font-size: 11px;
            color: #8a8aa0;
            margin: 15px 0 0 0;
            line-height: 1.6;
        }
        
        #physicsInfo strong {
            color: #a0a0b5;
            display: block;
            margin-bottom: 6px;
        }
        
        .math-formula {
            color: #9a9ab5;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            margin: 3px 0;
            padding-left: 4px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-5px); }
        }
        
        /* Body Info Modal */
        #bodyInfoModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 22, 35, 0.98);
            border: 1px solid rgba(100, 100, 120, 0.4);
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: none;
        }
        
        #bodyInfoModal.visible {
            display: block;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 100, 120, 0.2);
        }
        
        .modal-header h3 {
            margin: 0;
            color: #f0f0f5;
            font-size: 16px;
            font-weight: 500;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #8a8aa5;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 1;
        }
        
        .close-btn:hover {
            color: #d0d0e5;
        }
        
        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 5px 0;
        }
        
        .property-label {
            color: #8a8aa5;
            font-size: 12px;
            font-weight: 500;
        }
        
        .property-value {
            color: #d0d0e5;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .property-input {
            background: rgba(30, 30, 45, 0.6);
            border: 1px solid rgba(100, 100, 120, 0.3);
            color: #d0d0e5;
            padding: 5px 8px;
            font-size: 12px;
            border-radius: 3px;
            width: 100px;
            font-family: 'Courier New', monospace;
        }
        
        .property-input:focus {
            outline: none;
            border-color: rgba(120, 120, 150, 0.6);
        }
        
        /* Energy Graph */
        #energyGraph {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            height: 120px;
            background: rgba(22, 22, 35, 0.9);
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 4px;
            padding: 10px;
            display: none;
        }
        
        #energyGraph.visible {
            display: block;
        }
        
        #energyGraph canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Creation indicator */
        .creation-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px dashed rgba(100, 200, 255, 0.6);
            border-radius: 50%;
        }
        
        /* Instructions overlay */
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(22, 22, 35, 0.85);
            border: 1px solid rgba(100, 100, 120, 0.2);
            border-radius: 4px;
            padding: 10px 15px;
            font-size: 11px;
            color: #8a8aa5;
            max-width: 300px;
            line-height: 1.6;
        }
        
        #instructions strong {
            color: #a0a0b5;
            display: block;
            margin-bottom: 5px;
        }
        
        .instruction-item {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Simulation Control</h2>
        
        <div class="control-group">
            <button class="primary" onclick="toggleSimulation()" id="pauseBtn">Pause</button>
            <button onclick="resetSimulation()">Reset Simulation</button>
        </div>
        
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: 12px; border-radius: 8px; margin: 10px 0; text-align: center; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);" 
             onclick="startChallenge()" 
             onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)'" 
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'">
            <div style="font-size: 20px; margin-bottom: 5px;">üèÜ</div>
            <div style="font-weight: bold; font-size: 14px; color: white;">Challenge Mode</div>
            <div style="font-size: 11px; color: rgba(255,255,255,0.9); margin-top: 4px;">Create a stable periodic orbit!</div>
        </div>
        
        <h2>Initial Configurations</h2>
        <div class="preset-grid">
            <button onclick="loadPreset(0)" title="Moore's famous periodic solution - returns to start!">‚≠ê Figure-8</button>
            <button onclick="loadPreset(1)" title="Hierarchical stable orbits">üåÄ Stable</button>
            <button onclick="loadPreset(2)" title="Chaotic system - small changes = big effects!">üí• Chaotic</button>
            <button onclick="loadPreset(3)" title="Binary star with orbiting planet">üåü Binary</button>
            <button onclick="loadPreset(4)" title="Famous 3:4:5 mass ratio problem">üìê Pythagorean</button>
            <button onclick="loadPreset(5)" style="grid-column: 1 / -1; background: linear-gradient(180deg, #3a4a68 0%, #2a3a56 100%);" title="Realistic solar system scale">üåå Solar System</button>
        </div>
        
        <div style="background: rgba(100, 120, 200, 0.15); border: 1px solid rgba(100, 150, 255, 0.3); border-radius: 5px; padding: 12px; margin-top: 15px; font-size: 11px; line-height: 1.5;">
            <strong style="color: #8ac6ff;">üí° Challenge Tips:</strong><br>
            ‚Ä¢ Try Figure-8 - it's a <strong>periodic orbit</strong> that loops forever!<br>
            ‚Ä¢ Shift+Drag to create custom bodies<br>
            ‚Ä¢ Enable collisions to see bodies merge<br>
            ‚Ä¢ Watch energy conservation in action
        </div>
        
        <h2>Physics Parameters</h2>
        
        <div class="control-group">
            <label>Gravitational Constant: <span id="gValue">6.00</span></label>
            <input type="range" id="gSlider" min="0.5" max="20" step="0.5" value="6.0" oninput="updateG(this.value)">
        </div>
        
        <div class="control-group">
            <label>Time Scale: <span id="timeScaleValue">2.0x</span></label>
            <input type="range" id="timeScaleSlider" min="0.2" max="6" step="0.1" value="2.0" oninput="updateTimeScale(this.value)">
        </div>
        
        <div class="control-group">
            <label>Integration Step: <span id="dtValue">0.008</span></label>
            <input type="range" id="dtSlider" min="0.001" max="0.03" step="0.001" value="0.008" oninput="updateDt(this.value)">
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="chargeCheck" onchange="toggleChargeForces(this.checked)">
            <label for="chargeCheck">Enable Charge Forces</label>
        </div>

        <div class="control-group">
            <label>Charge Strength: <span id="chargeStrengthValue">1.0</span></label>
            <input type="range" id="chargeStrengthSlider" min="0" max="5" step="0.1" value="1.0" oninput="updateChargeStrength(this.value)">
        </div>

        <div class="control-group">
            <label>New Body Charge: <span id="newBodyChargeValue">0.00</span></label>
            <input type="range" id="newBodyChargeSlider" min="-5" max="5" step="0.1" value="0.0" oninput="updateNewBodyCharge(this.value)">
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="rk4Check" onchange="toggleIntegrator(this.checked)">
            <label for="rk4Check">RK4 Integration (higher accuracy)</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="collisionCheck" onchange="toggleCollisions(this.checked)">
            <label for="collisionCheck">Enable Collisions</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="mergingCheck" checked onchange="toggleMerging(this.checked)">
            <label for="mergingCheck">Body Merging</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="tidalCheck" onchange="toggleTidalForces(this.checked)">
            <label for="tidalCheck">Tidal Forces</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="gwCheck" onchange="toggleGravitationalWaves(this.checked)">
            <label for="gwCheck">Gravitational Waves</label>
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="boundaryCheck" onchange="toggleBoundaryMode(this.checked)">
            <label for="boundaryCheck">Containment Boundary</label>
        </div>

        <div class="control-group">
            <label>Boundary Padding: <span id="boundaryPaddingValue">40</span></label>
            <input type="range" id="boundaryPaddingSlider" min="10" max="150" step="5" value="40" oninput="updateBoundaryPadding(this.value)">
        </div>

        <div class="control-group">
            <label>Boundary Bounce: <span id="boundaryBounceValue">0.90</span></label>
            <input type="range" id="boundaryBounceSlider" min="0.1" max="1" step="0.05" value="0.9" oninput="updateBoundaryBounce(this.value)">
        </div>
        
        <div class="control-group">
            <label>Softening: <span id="softeningValue">0.5</span></label>
            <input type="range" id="softeningSlider" min="0" max="3" step="0.1" value="0.5" oninput="updateSoftening(this.value)">
        </div>
        
        <div class="control-group">
            <label>Collision Damping: <span id="dampingValue">0.80</span></label>
            <input type="range" id="dampingSlider" min="0" max="1" step="0.05" value="0.8" oninput="updateDamping(this.value)">
        </div>
        
        <h2>Display Settings</h2>
        
        <div class="checkbox-container">
            <input type="checkbox" id="trailCheck" checked onchange="toggleTrails()">
            <label for="trailCheck">Orbital Trails</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="velocityCheck" onchange="toggleVelocityVectors()">
            <label for="velocityCheck">Velocity Vectors</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="comCheck" onchange="toggleCenterOfMass()">
            <label for="comCheck">Center of Mass</label>
        </div>
        
        <div class="checkbox-container">
            <input type="checkbox" id="energyGraphCheck" onchange="toggleEnergyGraph()">
            <label for="energyGraphCheck">Energy Graph</label>
        </div>
        
        <div class="control-group">
            <label>Trail Opacity: <span id="trailOpacityValue">0.05</span></label>
            <input type="range" id="trailOpacitySlider" min="0.01" max="0.3" step="0.01" value="0.05" oninput="updateTrailOpacity(this.value)">
        </div>
        
        <h2>Conservation Laws</h2>
        <div id="stats">
            <div class="stat-row">
                <span class="stat-label">Bodies</span>
                <span class="stat-value" id="bodyCount">3</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Energy</span>
                <span class="stat-value" id="totalEnergy">0.0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Energy Drift</span>
                <span class="stat-value" id="energyDrift" style="color: #7a7a9a;">0.00%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Linear Momentum</span>
                <span class="stat-value" id="momentumMag">0.0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Momentum Drift</span>
                <span class="stat-value" id="momentumDrift" style="color: #7a7a9a;">0.00%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Angular Momentum</span>
                <span class="stat-value" id="angularMomentum">0.0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Frame Rate</span>
                <span class="stat-value" id="fps">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Simulation Time</span>
                <span class="stat-value" id="simTime">0.0s</span>
            </div>
        </div>
        
        <div id="physicsInfo">
            <strong>Classical Three-Body Problem:</strong>
            <div class="math-formula">‚Ä¢ Newton's Law: F = Gm‚ÇÅm‚ÇÇ/r¬≤</div>
            <div class="math-formula">‚Ä¢ Total Energy: E = ¬ΩŒ£mv¬≤ - Œ£Gm‚ÇÅm‚ÇÇ/r</div>
            <div class="math-formula">‚Ä¢ Linear Momentum: P = Œ£m·µ¢v·µ¢ (conserved)</div>
            <div class="math-formula">‚Ä¢ Angular Momentum: L = Œ£r·µ¢ √ó p·µ¢ (conserved)</div>
            <div class="math-formula">‚Ä¢ Numerical: Verlet (symplectic) or RK4</div>
            <div class="math-formula">‚Ä¢ Softening Œµ prevents r‚Üí0 singularities</div>
        </div>
        
        <div id="funFact" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 8px; padding: 15px; margin-top: 15px;">
            <div style="font-size: 12px; font-weight: 600; color: #ffd93d; margin-bottom: 8px;">üí° Did You Know?</div>
            <div id="funFactText" style="font-size: 11px; line-height: 1.6; color: #d0d0e5;">
                The three-body problem has no general closed-form solution. Henri Poincar√© proved this in 1889!
            </div>
            <button onclick="rotateFunFact()" style="margin-top: 10px; width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                üîÑ Next Fact
            </button>
        </div>
    </div>
    
    <div id="mainContent">
        <h1>üåå The Three-Body Problem Challenge</h1>
        <div style="text-align: center; margin-top: -15px; margin-bottom: 20px; font-size: 13px; color: #9d9db0;">
            Explore gravitational chaos & hunt for periodic orbits | <span style="color: #4ecdc4;">Built with WebAssembly</span>
        </div>
        
        <div id="loading">Initializing physics engine...</div>
        
        <div id="canvasContainer" style="display: none;">
            <canvas id="canvas" width="900" height="700"></canvas>
            
            <!-- Instructions overlay -->
            <div id="instructions" style="animation: fadeIn 1s ease;">
                <strong style="color: #4ecdc4;">üéÆ Interactive Controls:</strong>
                <div class="instruction-item">üñ±Ô∏è Click & drag bodies to move them</div>
                <div class="instruction-item" style="background: rgba(100, 200, 255, 0.1); padding: 3px 6px; border-radius: 3px; margin: 3px 0;">‚áß <strong>Shift + drag</strong> to create new bodies with velocity!</div>
                <div class="instruction-item">‚åò/Ctrl + drag to pan camera</div>
                <div class="instruction-item">üñ±Ô∏è Scroll to zoom in/out</div>
                <div class="instruction-item">‚ê£ Space to pause/resume</div>
                <div class="instruction-item">‚å´ Delete to remove selected body</div>
                <div class="instruction-item">T to toggle trails, V for vectors</div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(100, 100, 120, 0.3); font-size: 10px; color: #6a8aa5;">
                    üí° <strong>Pro Tip:</strong> Try recreating the Figure-8 orbit!
                </div>
            </div>
            
            <style>
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(-10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
            </style>
            
            <!-- Energy graph -->
            <div id="energyGraph">
                <canvas id="energyCanvas" width="230" height="100"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Body Info Modal -->
    <div id="bodyInfoModal">
        <div class="modal-header">
            <h3>Body Properties</h3>
            <button class="close-btn" onclick="hideBodyInfo()">√ó</button>
        </div>
        <div id="bodyInfoContent">
            <div class="property-row">
                <span class="property-label">Position X:</span>
                <input type="number" class="property-input" id="bodyPosX" step="1">
            </div>
            <div class="property-row">
                <span class="property-label">Position Y:</span>
                <input type="number" class="property-input" id="bodyPosY" step="1">
            </div>
            <div class="property-row">
                <span class="property-label">Velocity X:</span>
                <input type="number" class="property-input" id="bodyVelX" step="0.1">
            </div>
            <div class="property-row">
                <span class="property-label">Velocity Y:</span>
                <input type="number" class="property-input" id="bodyVelY" step="0.1">
            </div>
            <div class="property-row">
                <span class="property-label">Mass:</span>
                <input type="number" class="property-input" id="bodyMass" step="1">
            </div>
            <div class="property-row">
                <span class="property-label">Charge:</span>
                <input type="number" class="property-input" id="bodyCharge" step="0.1">
            </div>
            <div class="property-row">
                <span class="property-label">Speed:</span>
                <span class="property-value" id="bodySpeed">0.0</span>
            </div>
            <div class="property-row">
                <span class="property-label">KE:</span>
                <span class="property-value" id="bodyKE">0.0</span>
            </div>
            <button onclick="applyBodyChanges()" style="margin-top: 10px;">Apply Changes</button>
            <button onclick="deleteSelectedBody()" style="background: linear-gradient(180deg, #5a2a2a 0%, #3a1a1a 100%);">Delete Body</button>
        </div>
    </div>

    <script>
        var Module = {
            onRuntimeInitialized: function() {
                console.log('WebAssembly module loaded');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('canvasContainer').style.display = 'block';
                startSimulation();
            }
        };
    </script>
    <script src="main.js"></script>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let isRunning = true;
        let showTrails = true;
        let showVelocityVectors = false;
        let showCenterOfMass = false;
        let trailOpacity = 0.05;
        let frameCount = 0;
        let lastTime = Date.now();
        let simulationTime = 0;
        let newBodyCharge = 0.0;
        
        // Particle system for collisions
        let particles = [];
        
        // Periodic orbit detection
        let initialState = null;
        let periodicityCheckInterval = 100;
        let periodicityThreshold = 0.1;
        
        // Camera controls
        let cameraX = 0;
        let cameraY = 0;
        let cameraZoom = 1.0;
        let isDraggingCamera = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Interactive controls
        let isDraggingBody = false;
        let draggedBodyIndex = -1;
        let isCreatingBody = false;
        let creationStartX = 0;
        let creationStartY = 0;
        let selectedBodyIndex = -1;
        
        // Energy history for graphing
        let energyHistory = [];
        const maxHistoryLength = 200;
        const UNIT_LENGTH_IN_KM = 1000; // assume 1 canvas unit ‚âà 1000 km for display labels
        const UNIT_TIME_IN_SECONDS = 3600; // treat dt units as roughly one hour for km/s estimation
        const UNIT_VELOCITY_IN_KM_PER_S = UNIT_LENGTH_IN_KM / UNIT_TIME_IN_SECONDS;
        const DIALOGUE_DURATION_MS = 6000;
        const DIALOGUE_GAP_MS = 1500;
        let hudPhase = 0;
        const physicsQuips = [
            "Photon checking in‚Äîtraveling light, of course!",
            "I'm not lazy, I'm conserving energy.",
            "Gravity keeps pulling me back into drama.",
            "I orbit because running in circles burns calories.",
            "Charge me up before you go-go.",
            "Is it hot in here or is it just my kinetic energy?",
            "Please respect my personal space-time.",
            "I tried to be punctual but time dilated.",
            "You call it chaos, I call it choreography.",
            "Keep pushing me and I'll go quantum on you.",
            "Friction? Never met her.",
            "Mass times sass equals attitude.",
            "I'm in a stable relationship‚Äîwith my orbit.",
            "Just because I'm eccentric doesn't mean I'm unstable.",
            "Charge ahead, regret later.",
            "My potential energy is unmatched.",
            "Stop staring; it's making my wavefunction collapse.",
            "Momentum called‚Äîit wants to keep going.",
            "I'm positively charged with negativity.",
            "Is there an off switch for tidal drama?",
            "Who scheduled this close encounter?",
            "I fling jokes at the speed of light.",
            "These collisions are getting out of hand.",
            "Orbiting: the cosmic version of pacing.",
            "Angular momentum? More like angular annoyance.",
            "Rest mass? Never heard of her.",
            "I only repel when absolutely necessary.",
            "My feelings are quantized‚Äîtake it or leave it.",
            "Please stop poking my potential well.",
            "Center of mass? More like center of attention.",
            "Why yes, my field is indeed intense.",
            "I came, I saw, I accelerated.",
            "Keep calm and integrate numerically.",
            "My orbit predicted this conversation.",
            "Force equals ma, and I'm full of a.",
            "Not to boast, but my charge is attractive.",
            "Another day, another conservation law.",
            "I can't even‚Äîangular momentum says so.",
            "Stop colliding with my vibe.",
            "If you're not part of the solution, you're precipitating.",
            "I'm inelastic when it suits me.",
            "Bond with me and it's a stable union.",
            "Drag me one more time and I'll fragment.",
            "My jokes are superluminal‚Äîtry to catch up.",
            "At least my charge has personality.",
            "Event horizon? Sounds like a boundary issue.",
            "This simulation needs more snacks.",
            "Field lines? I prefer field vibes.",
            "Zero-point energy keeps me awake at night.",
            "Annoyed? I'm positively fuming.",
            "You're blocking my path integral!"
        ];
        const dialogueState = new Map();
        let lastDialogueBodyCount = 0;
        
        function toggleSimulation() {
            isRunning = !isRunning;
            document.getElementById('pauseBtn').textContent = isRunning ? 'Pause' : 'Resume';
        }
        
        function resetSimulation() {
            Module._reset();
            simulationTime = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function loadPreset(presetId) {
            Module._loadPreset(presetId);
            simulationTime = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            particles = [];
            setTimeout(() => saveInitialState(), 100);
        }
        
        function updateG(value) {
            Module._setGravitationalConstant(parseFloat(value));
            document.getElementById('gValue').textContent = parseFloat(value).toFixed(2);
        }
        
        function updateTimeScale(value) {
            Module._setTimeScale(parseFloat(value));
            document.getElementById('timeScaleValue').textContent = parseFloat(value).toFixed(1) + 'x';
        }
        
        function updateDt(value) {
            Module._setTimeStep(parseFloat(value));
            document.getElementById('dtValue').textContent = parseFloat(value).toFixed(3);
        }
        
        function toggleIntegrator(useRK4) {
            Module._setIntegrator(useRK4 ? 1 : 0);
        }
        
        function toggleCollisions(enabled) {
            Module._setCollisions(enabled ? 1 : 0);
        }
        
        function toggleMerging(enabled) {
            Module._setMergingEnabled(enabled ? 1 : 0);
        }
        
        function toggleTidalForces(enabled) {
            Module._setTidalForces(enabled ? 1 : 0);
        }
        
        function toggleGravitationalWaves(enabled) {
            Module._setGravitationalWaves(enabled ? 1 : 0);
        }
        
        function updateSoftening(value) {
            Module._setSofteningLength(parseFloat(value));
            document.getElementById('softeningValue').textContent = parseFloat(value).toFixed(1);
        }
        
        function updateDamping(value) {
            Module._setCollisionDamping(parseFloat(value));
            document.getElementById('dampingValue').textContent = parseFloat(value).toFixed(2);
        }
        
        function toggleTrails() {
            showTrails = !showTrails;
            if (!showTrails) {
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        function toggleVelocityVectors() {
            showVelocityVectors = !showVelocityVectors;
        }
        
        function toggleCenterOfMass() {
            showCenterOfMass = !showCenterOfMass;
        }
        
        function toggleEnergyGraph() {
            const graphElement = document.getElementById('energyGraph');
            graphElement.classList.toggle('visible');
        }
        
        function updateTrailOpacity(value) {
            trailOpacity = parseFloat(value);
            document.getElementById('trailOpacityValue').textContent = parseFloat(value).toFixed(2);
        }

        function toggleChargeForces(enabled) {
            Module._setChargeForces(enabled ? 1 : 0);
        }

        function updateChargeStrength(value) {
            Module._setElectrostaticConstant(parseFloat(value));
            document.getElementById('chargeStrengthValue').textContent = parseFloat(value).toFixed(1);
        }

        function updateNewBodyCharge(value) {
            newBodyCharge = parseFloat(value);
            document.getElementById('newBodyChargeValue').textContent = newBodyCharge.toFixed(2);
        }

        function toggleBoundaryMode(enabled) {
            Module._setBoundaryMode(enabled ? 1 : 0);
        }

        function updateBoundaryPadding(value) {
            Module._setBoundaryPadding(parseFloat(value));
            document.getElementById('boundaryPaddingValue').textContent = parseFloat(value).toFixed(0);
        }

        function updateBoundaryBounce(value) {
            Module._setBoundaryRestitution(parseFloat(value));
            document.getElementById('boundaryBounceValue').textContent = parseFloat(value).toFixed(2);
        }

        function syncPhysicsDefaults() {
            // Ensure WASM side uses the same defaults shown in the UI controls
            updateG(document.getElementById('gSlider').value);
            updateTimeScale(document.getElementById('timeScaleSlider').value);
            updateDt(document.getElementById('dtSlider').value);
            updateSoftening(document.getElementById('softeningSlider').value);
            updateDamping(document.getElementById('dampingSlider').value);
            toggleCollisions(document.getElementById('collisionCheck').checked);
            toggleMerging(document.getElementById('mergingCheck').checked);
            toggleTidalForces(document.getElementById('tidalCheck').checked);
            toggleGravitationalWaves(document.getElementById('gwCheck').checked);
            toggleChargeForces(document.getElementById('chargeCheck').checked);
            updateChargeStrength(document.getElementById('chargeStrengthSlider').value);
            updateNewBodyCharge(document.getElementById('newBodyChargeSlider').value);
            toggleBoundaryMode(document.getElementById('boundaryCheck').checked);
            updateBoundaryPadding(document.getElementById('boundaryPaddingSlider').value);
            updateBoundaryBounce(document.getElementById('boundaryBounceSlider').value);
        }
        
        function updateBodyInfo(bodyIndex) {
            if (bodyIndex < 0 || bodyIndex >= Module._getBodyCount()) return;
            
            selectedBodyIndex = bodyIndex;
            const x = Module._getBodyX(bodyIndex);
            const y = Module._getBodyY(bodyIndex);
            const vx = Module._getBodyVX(bodyIndex);
            const vy = Module._getBodyVY(bodyIndex);
            const mass = Module._getBodyMass(bodyIndex);
            const charge = Module._getBodyCharge(bodyIndex);
            const speed = Math.sqrt(vx * vx + vy * vy);
            const ke = Module._getKineticEnergy(bodyIndex);
            
            document.getElementById('bodyPosX').value = x.toFixed(2);
            document.getElementById('bodyPosY').value = y.toFixed(2);
            document.getElementById('bodyVelX').value = vx.toFixed(3);
            document.getElementById('bodyVelY').value = vy.toFixed(3);
            document.getElementById('bodyMass').value = mass.toFixed(2);
            document.getElementById('bodyCharge').value = charge.toFixed(2);
            document.getElementById('bodySpeed').textContent = speed.toFixed(3);
            document.getElementById('bodyKE').textContent = ke.toFixed(2);
            
            document.getElementById('bodyInfoModal').classList.add('visible');
        }
        
        function hideBodyInfo() {
            document.getElementById('bodyInfoModal').classList.remove('visible');
            selectedBodyIndex = -1;
        }
        
        function applyBodyChanges() {
            if (selectedBodyIndex < 0) return;
            
            const x = parseFloat(document.getElementById('bodyPosX').value);
            const y = parseFloat(document.getElementById('bodyPosY').value);
            const vx = parseFloat(document.getElementById('bodyVelX').value);
            const vy = parseFloat(document.getElementById('bodyVelY').value);
            const mass = parseFloat(document.getElementById('bodyMass').value);
            const charge = parseFloat(document.getElementById('bodyCharge').value);
            
            Module._setBodyPosition(selectedBodyIndex, x, y);
            Module._setBodyVelocity(selectedBodyIndex, vx, vy);
            Module._setBodyMass(selectedBodyIndex, mass);
            Module._setBodyCharge(selectedBodyIndex, charge);
            Module._saveState();
            
            updateBodyInfo(selectedBodyIndex);
        }
        
        function deleteSelectedBody() {
            if (selectedBodyIndex < 0) return;
            Module._removeBody(selectedBodyIndex);
            hideBodyInfo();
        }
        
        function updateEnergyGraph() {
            const energy = Module._getTotalEnergy();
            energyHistory.push(energy);
            if (energyHistory.length > maxHistoryLength) {
                energyHistory.shift();
            }
            
            const energyCanvas = document.getElementById('energyCanvas');
            if (!energyCanvas) return;
            
            const gctx = energyCanvas.getContext('2d');
            gctx.clearRect(0, 0, energyCanvas.width, energyCanvas.height);
            
            if (energyHistory.length < 2) return;
            
            // Find min/max for scaling
            const minE = Math.min(...energyHistory);
            const maxE = Math.max(...energyHistory);
            const range = maxE - minE || 1;
            
            // Draw grid
            gctx.strokeStyle = 'rgba(100, 100, 120, 0.2)';
            gctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (energyCanvas.height * i) / 4;
                gctx.beginPath();
                gctx.moveTo(0, y);
                gctx.lineTo(energyCanvas.width, y);
                gctx.stroke();
            }
            
            // Draw energy line
            gctx.strokeStyle = '#4ECDC4';
            gctx.lineWidth = 2;
            gctx.beginPath();
            
            for (let i = 0; i < energyHistory.length; i++) {
                const x = (i / maxHistoryLength) * energyCanvas.width;
                const normalized = (energyHistory[i] - minE) / range;
                const y = energyCanvas.height - (normalized * energyCanvas.height);
                
                if (i === 0) {
                    gctx.moveTo(x, y);
                } else {
                    gctx.lineTo(x, y);
                }
            }
            gctx.stroke();
            
            // Draw labels
            gctx.fillStyle = '#8a8aa5';
            gctx.font = '10px monospace';
            gctx.fillText('E: ' + energy.toFixed(2), 5, 12);
        }
        
        function rgbaToStyle(rgba) {
            const r = (rgba >> 24) & 0xFF;
            const g = (rgba >> 16) & 0xFF;
            const b = (rgba >> 8) & 0xFF;
            const a = (rgba & 0xFF) / 255;
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        
        function drawBody(x, y, radius, color) {
            // Extract RGBA components from packed color
            const r = (color >> 24) & 0xFF;
            const g = (color >> 16) & 0xFF;
            const b = (color >> 8) & 0xFF;
            const a = (color & 0xFF) / 255;
            
            // Ensure radius is positive and visible (minimum 5 pixels)
            radius = Math.max(Math.abs(radius), 5);
            
            // Enhanced atmospheric glow with pulsing effect
            const pulseIntensity = 1 + Math.sin(frameCount * 0.05) * 0.15;
            const glowGradient = ctx.createRadialGradient(x, y, radius * 0.8, x, y, radius * 2.5 * pulseIntensity);
            glowGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.3 * pulseIntensity})`);
            glowGradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.15)`);
            glowGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            ctx.beginPath();
            ctx.arc(x, y, radius * 2.5 * pulseIntensity, 0, Math.PI * 2);
            ctx.fillStyle = glowGradient;
            ctx.fill();
            
            // Draw main planet body with lighting
            const lightOffsetX = -radius * 0.3;
            const lightOffsetY = -radius * 0.3;
            const planetGradient = ctx.createRadialGradient(
                x + lightOffsetX, y + lightOffsetY, radius * 0.1,
                x, y, radius
            );
            
            // Bright highlight
            planetGradient.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, ${a})`);
            // Main color
            planetGradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, ${a})`);
            // Darker edge for sphere effect
            planetGradient.addColorStop(1, `rgba(${Math.max(0, r - 50)}, ${Math.max(0, g - 50)}, ${Math.max(0, b - 50)}, ${a})`);
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = planetGradient;
            ctx.fill();
            
            // Add subtle rim lighting on the shadow side
            const rimGradient = ctx.createRadialGradient(
                x - lightOffsetX * 2, y - lightOffsetY * 2, radius * 0.3,
                x, y, radius * 1.2
            );
            rimGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0)`);
            rimGradient.addColorStop(0.8, `rgba(${Math.min(255, r + 30)}, ${Math.min(255, g + 30)}, ${Math.min(255, b + 30)}, 0.2)`);
            rimGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = rimGradient;
            ctx.fill();
        }
        
        function drawVelocityVector(x, y, vx, vy, color) {
            const scale = 10;
            const endX = x + vx * scale;
            const endY = y + vy * scale;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = rgbaToStyle(color);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            const angle = Math.atan2(vy, vx);
            const headLen = 8;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI/6), 
                      endY - headLen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI/6), 
                      endY - headLen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }
        
        function drawBodyHud(x, y, radius, vx, vy, charge, index) {
            const speed = Math.sqrt(vx * vx + vy * vy) * UNIT_VELOCITY_IN_KM_PER_S;
            const labelLines = [
                `|v| ‚âà ${speed.toFixed(2)} km/s`,
                `q = ${charge.toFixed(2)} C`
            ];
            const padding = 6;
            const lineHeight = 12;
            const bubbleWidth = 130;
            const bubbleHeight = labelLines.length * lineHeight + padding * 2;
            const offsetX = (index % 2 === 0 ? 1 : -1) * (radius + 20);
            const offsetY = Math.sin(hudPhase + index) * 5;
            const bubbleX = x + offsetX - bubbleWidth / 2;
            const bubbleY = y - radius - bubbleHeight - 5 + offsetY;
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = 'rgba(20,20,35,0.85)';
            ctx.strokeStyle = 'rgba(80,150,255,0.8)';
            ctx.lineWidth = 1;
            const r = 6;
            ctx.beginPath();
            ctx.moveTo(bubbleX + r, bubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - r, bubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + r);
            ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - r);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - r, bubbleY + bubbleHeight);
            ctx.lineTo(bubbleX + r, bubbleY + bubbleHeight);
            ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - r);
            ctx.lineTo(bubbleX, bubbleY + r);
            ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + r, bubbleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#e0e4ff';
            ctx.font = '11px "JetBrains Mono", monospace';
            ctx.textBaseline = 'top';
            labelLines.forEach((line, idx) => {
                ctx.fillText(line, bubbleX + padding, bubbleY + padding + idx * lineHeight);
            });
            ctx.restore();
        }
        
        function wrapDialogueText(text, maxChars) {
            const words = text.split(' ');
            const lines = [];
            let current = '';
            for (const word of words) {
                if ((current + word).length > maxChars) {
                    lines.push(current.trim());
                    current = word + ' ';
                } else {
                    current += word + ' ';
                }
            }
            if (current.trim().length) {
                lines.push(current.trim());
            }
            return lines;
        }
        
        function getDialogueForBody(index) {
            const now = performance.now();
            const existing = dialogueState.get(index);
            if (!existing || now > existing.expireTime) {
                const text = physicsQuips[Math.floor(Math.random() * physicsQuips.length)];
                dialogueState.set(index, {
                    text,
                    expireTime: now + DIALOGUE_DURATION_MS + Math.random() * 2000,
                    reappearTime: now + DIALOGUE_DURATION_MS + DIALOGUE_GAP_MS
                });
                return text;
            }
            if (now > existing.reappearTime) {
                const text = physicsQuips[Math.floor(Math.random() * physicsQuips.length)];
                dialogueState.set(index, {
                    text,
                    expireTime: now + DIALOGUE_DURATION_MS,
                    reappearTime: now + DIALOGUE_DURATION_MS + DIALOGUE_GAP_MS
                });
                return text;
            }
            return existing.text;
        }
        
        function drawDialogueBubble(x, y, radius, text, index) {
            const lines = wrapDialogueText(text, 28);
            const padding = 10;
            const lineHeight = 14;
            const bubbleHeight = padding * 2 + lines.length * lineHeight;
            const bubbleWidth = 180;
            const offsetDirection = index % 2 === 0 ? -1 : 1;
            let bubbleX = x + offsetDirection * (radius + 30);
            if (offsetDirection < 0) {
                bubbleX -= bubbleWidth;
            }
            const bubbleY = y - radius - bubbleHeight - 20;
            const pointerX = x + offsetDirection * radius * 0.5;
            const pointerY = y - radius;
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(15,15,30,0.92)';
            ctx.strokeStyle = offsetDirection > 0 ? '#ffb347' : '#8ef2ff';
            ctx.lineWidth = 1.5;
            const r = 10;
            ctx.beginPath();
            ctx.moveTo(bubbleX + r, bubbleY);
            ctx.lineTo(bubbleX + bubbleWidth - r, bubbleY);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + r);
            ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - r);
            ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - r, bubbleY + bubbleHeight);
            ctx.lineTo(pointerX + 8, bubbleY + bubbleHeight);
            ctx.lineTo(pointerX, pointerY);
            ctx.lineTo(pointerX - 8, bubbleY + bubbleHeight);
            ctx.lineTo(bubbleX + r, bubbleY + bubbleHeight);
            ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - r);
            ctx.lineTo(bubbleX, bubbleY + r);
            ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + r, bubbleY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#f4f4ff';
            ctx.font = '12px "Arial", sans-serif';
            ctx.textBaseline = 'top';
            lines.forEach((line, idxLine) => {
                ctx.fillText(line, bubbleX + padding, bubbleY + padding + idxLine * lineHeight);
            });
            ctx.restore();
        }
        
        function drawCenterOfMass(cmX, cmY) {
            ctx.beginPath();
            ctx.arc(cmX, cmY, 5, 0, Math.PI * 2);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(cmX - 10, cmY);
            ctx.lineTo(cmX + 10, cmY);
            ctx.moveTo(cmX, cmY - 10);
            ctx.lineTo(cmX, cmY + 10);
            ctx.stroke();
        }
        
        // Particle system for collision effects
        function createCollisionParticles(x, y, color1, color2, intensity = 1) {
            const particleCount = Math.floor(30 * intensity);
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 2 + Math.random() * 4 * intensity;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.01,
                    size: 2 + Math.random() * 3,
                    color: i % 2 === 0 ? color1 : color2
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            ctx.save();
            for (const p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = rgbaToStyle(p.color);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        
        // Periodic orbit detection
        function saveInitialState() {
            initialState = {
                bodies: [],
                time: simulationTime
            };
            const count = Module._getBodyCount();
            for (let i = 0; i < count; i++) {
                initialState.bodies.push({
                    x: Module._getBodyX(i),
                    y: Module._getBodyY(i),
                    vx: Module._getBodyVX(i),
                    vy: Module._getBodyVY(i)
                });
            }
        }
        
        function checkPeriodicity() {
            if (!initialState || simulationTime < 5) return;
            
            const count = Module._getBodyCount();
            if (count !== initialState.bodies.length) return;
            
            let totalDist = 0;
            for (let i = 0; i < count; i++) {
                const dx = Module._getBodyX(i) - initialState.bodies[i].x;
                const dy = Module._getBodyY(i) - initialState.bodies[i].y;
                const dvx = Module._getBodyVX(i) - initialState.bodies[i].vx;
                const dvy = Module._getBodyVY(i) - initialState.bodies[i].vy;
                totalDist += Math.sqrt(dx*dx + dy*dy + dvx*dvx + dvy*dvy);
            }
            
            const avgDist = totalDist / count;
            if (avgDist < periodicityThreshold) {
                showPeriodicNotification();
            }
        }
        
        function showPeriodicNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                font-size: 16px;
                font-weight: bold;
                box-shadow: 0 8px 32px rgba(102, 126, 234, 0.5);
                z-index: 10000;
                animation: slideDown 0.5s ease;
            `;
            notification.textContent = 'üåü Periodic Orbit Detected! Bodies returned to initial state!';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideUp 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
            
            // Add animation keyframes if not already present
            if (!document.getElementById('periodicAnimations')) {
                const style = document.createElement('style');
                style.id = 'periodicAnimations';
                style.textContent = `
                    @keyframes slideDown {
                        from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                    @keyframes slideUp {
                        from { transform: translateX(-50%) translateY(0); opacity: 1; }
                        to { transform: translateX(-50%) translateY(-100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        function updateStats() {
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            
            if (deltaTime >= 1.0) {
                const fps = Math.round(frameCount / deltaTime);
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }
            
            document.getElementById('simTime').textContent = simulationTime.toFixed(2) + 's';
            document.getElementById('bodyCount').textContent = Module._getBodyCount();
            document.getElementById('totalEnergy').textContent = Module._getTotalEnergy().toFixed(2);
            
            // Calculate momentum magnitude
            const momX = Module._getMomentumX();
            const momY = Module._getMomentumY();
            const momMag = Math.sqrt(momX * momX + momY * momY);
            document.getElementById('momentumMag').textContent = momMag.toFixed(3);
            
            document.getElementById('angularMomentum').textContent = Module._getAngularMomentum().toFixed(2);
            
            // Conservation drift monitoring
            const energyDrift = Module._getEnergyDrift() * 100;  // Convert to percentage
            const momentumDrift = Module._getMomentumDrift() * 100;
            
            const energyDriftEl = document.getElementById('energyDrift');
            energyDriftEl.textContent = energyDrift.toFixed(4) + '%';
            // Color code: green if < 0.1%, yellow if < 1%, red if >= 1%
            if (energyDrift < 0.1) {
                energyDriftEl.style.color = '#4ade80';
            } else if (energyDrift < 1.0) {
                energyDriftEl.style.color = '#fbbf24';
            } else {
                energyDriftEl.style.color = '#f87171';
            }
            
            const momentumDriftEl = document.getElementById('momentumDrift');
            momentumDriftEl.textContent = momentumDrift.toFixed(4) + '%';
            if (momentumDrift < 0.1) {
                momentumDriftEl.style.color = '#4ade80';
            } else if (momentumDrift < 1.0) {
                momentumDriftEl.style.color = '#fbbf24';
            } else {
                momentumDriftEl.style.color = '#f87171';
            }
        }
        
        function animate() {
            if (isRunning) {
                // Track previous positions for collision detection
                const prevCount = Module._getBodyCount();
                const prevPositions = [];
                for (let i = 0; i < prevCount; i++) {
                    prevPositions.push({
                        x: Module._getBodyX(i),
                        y: Module._getBodyY(i),
                        color: Module._getBodyColor(i)
                    });
                }
                
                for (let i = 0; i < 5; i++) {
                    Module._update();
                    simulationTime += Module._getTimeStep();
                }
                
                // Check for collisions (body count changed)
                const newCount = Module._getBodyCount();
                if (newCount < prevCount && prevPositions.length >= 2) {
                    // Collision occurred! Create particles
                    const collisionX = prevPositions.reduce((sum, p) => sum + p.x, 0) / prevPositions.length;
                    const collisionY = prevPositions.reduce((sum, p) => sum + p.y, 0) / prevPositions.length;
                    createCollisionParticles(collisionX, collisionY, prevPositions[0].color, prevPositions[1].color, 2.0);
                }
            }
            hudPhase += 0.02;
            
            // Trail effect
            if (showTrails) {
                ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Apply camera transform
            ctx.save();
            ctx.translate(cameraX, cameraY);
            ctx.scale(cameraZoom, cameraZoom);
            
            // Draw center of mass
            if (showCenterOfMass) {
                const cmX = Module._getCenterOfMassX();
                const cmY = Module._getCenterOfMassY();
                drawCenterOfMass(cmX, cmY);
            }
            
            // Draw gravitational interaction lines when bodies are close
            const bodyCount = Module._getBodyCount();
            if (bodyCount !== lastDialogueBodyCount) {
                dialogueState.clear();
                lastDialogueBodyCount = bodyCount;
            }
            for (let i = 0; i < bodyCount; i++) {
                for (let j = i + 1; j < bodyCount; j++) {
                    const x1 = Module._getBodyX(i);
                    const y1 = Module._getBodyY(i);
                    const x2 = Module._getBodyX(j);
                    const y2 = Module._getBodyY(j);
                    const dist = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
                    
                    // Draw connection line when bodies are close
                    if (dist < 150) {
                        const intensity = 1 - (dist / 150);
                        ctx.strokeStyle = `rgba(100, 200, 255, ${intensity * 0.3})`;
                        ctx.lineWidth = intensity * 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
            
            // Draw bodies and velocity vectors
            for (let i = 0; i < bodyCount; i++) {
                const x = Module._getBodyX(i);
                const y = Module._getBodyY(i);
                const radius = Module._getBodyRadius(i);
                const color = Module._getBodyColor(i);
                const vx = Module._getBodyVX(i);
                const vy = Module._getBodyVY(i);
                const charge = Module._getBodyCharge(i);
                
                drawBody(x, y, radius, color);
                
                // Highlight selected body
                if (i === selectedBodyIndex) {
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 1.5, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (showVelocityVectors) {
                    drawVelocityVector(x, y, vx, vy, color);
                }
                drawBodyHud(x, y, radius, vx, vy, charge, i);
                const dialogue = getDialogueForBody(i);
                if (dialogue) {
                    drawDialogueBubble(x, y, radius, dialogue, i);
                }
            }
            
            // Update and draw particles
            updateParticles();
            drawParticles();
            
            // Check for periodic orbits
            if (frameCount % periodicityCheckInterval === 0) {
                checkPeriodicity();
            }
            
            // Draw creation indicator
            if (isCreatingBody) {
                const rect = canvas.getBoundingClientRect();
                // Use stored mouse position from event handlers
                const dx = (lastMouseX || creationStartX) - creationStartX;
                const dy = (lastMouseY || creationStartY) - creationStartY;
                
                // Draw creation circle
                ctx.beginPath();
                ctx.arc(creationStartX, creationStartY, 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                if (dx !== 0 || dy !== 0) {
                    // Draw velocity arrow
                    ctx.beginPath();
                    ctx.moveTo(creationStartX, creationStartY);
                    ctx.lineTo(creationStartX + dx, creationStartY + dy);
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw arrowhead
                    const angle = Math.atan2(dy, dx);
                    const headLen = 10;
                    const endX = creationStartX + dx;
                    const endY = creationStartY + dy;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI/6), 
                              endY - headLen * Math.sin(angle - Math.PI/6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI/6), 
                              endY - headLen * Math.sin(angle + Math.PI/6));
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            
            // Update stats and energy graph periodically
            frameCount++;
            if (frameCount % 10 === 0) {
                updateStats();
                updateEnergyGraph();
                
                // Check for achievements
                if (frameCount === 1000) {
                    showAchievement('‚è±Ô∏è Time Traveler', 'Simulated for 100+ time units!', '#ffd93d');
                }
                
                const energyDrift = Module._getEnergyDrift() * 100;
                if (frameCount > 500 && energyDrift < 0.01) {
                    showAchievement('üéØ Perfect Conservation', 'Energy drift < 0.01% - excellent numerics!', '#4ade80');
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function startSimulation() {
            Module._init();
            syncPhysicsDefaults();
            lastTime = Date.now();
            saveInitialState();
            animate();
            
            // Show welcome message
            setTimeout(() => {
                showAchievement('üöÄ Simulation Started!', 'Try the Figure-8 preset to see a periodic orbit', '#4ecdc4');
            }, 1000);
        }
        
        function showAchievement(title, description, color = '#667eea') {
            const achievement = document.createElement('div');
            achievement.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                font-size: 14px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
                z-index: 10000;
                max-width: 300px;
                animation: slideInRight 0.5s ease;
            `;
            achievement.innerHTML = `<strong>${title}</strong><br><span style="font-size: 12px; opacity: 0.9;">${description}</span>`;
            document.body.appendChild(achievement);
            
            setTimeout(() => {
                achievement.style.animation = 'slideOutRight 0.5s ease';
                setTimeout(() => achievement.remove(), 500);
            }, 4000);
            
            if (!document.getElementById('achievementAnimations')) {
                const style = document.createElement('style');
                style.id = 'achievementAnimations';
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(400px); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOutRight {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(400px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        let challengeMode = false;
        let challengeStartTime = 0;
        
        function startChallenge() {
            challengeMode = true;
            challengeStartTime = simulationTime;
            
            // Clear current simulation
            Module._reset();
            simulationTime = 0;
            particles = [];
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Show challenge instructions
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 20000;
                animation: fadeIn 0.3s ease;
            `;
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
                            padding: 40px; 
                            border-radius: 20px; 
                            max-width: 500px;
                            border: 2px solid #667eea;
                            box-shadow: 0 20px 60px rgba(102, 126, 234, 0.4);">
                    <h2 style="color: #4ecdc4; margin-top: 0; font-size: 28px; text-align: center;">
                        üèÜ Challenge: Periodic Orbit
                    </h2>
                    <div style="color: #e8eaf6; line-height: 1.8; font-size: 15px; margin: 20px 0;">
                        <p><strong style="color: #ffd93d;">Your Mission:</strong></p>
                        <p>Create a configuration where all three bodies return to their starting positions!</p>
                        
                        <p style="margin-top: 20px;"><strong style="color: #ff6b9d;">How to Win:</strong></p>
                        <ul style="padding-left: 20px;">
                            <li>Use <strong>Shift + Drag</strong> to create 3 bodies</li>
                            <li>Give them velocities by dragging</li>
                            <li>Bodies must return within 0.1 units of start</li>
                            <li>Or... just load the Figure-8 preset! üòâ</li>
                        </ul>
                        
                        <p style="margin-top: 20px; padding: 15px; background: rgba(255, 107, 109, 0.1); border-left: 3px solid #ff6b6b; border-radius: 5px; font-size: 13px;">
                            <strong>üí° Physics Tip:</strong> Periodic solutions are incredibly rare! 
                            The Figure-8 orbit discovered by Moore (1993) was a breakthrough finding.
                        </p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="width: 100%; 
                                   padding: 15px; 
                                   background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                   border: none;
                                   border-radius: 10px;
                                   color: white;
                                   font-size: 16px;
                                   font-weight: bold;
                                   cursor: pointer;
                                   transition: all 0.3s ease;"
                            onmouseover="this.style.transform='scale(1.05)'"
                            onmouseout="this.style.transform='scale(1)'">
                        Let's Go! üöÄ
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }
        
        // Mouse/Touch interaction handlers
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel);
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (e.shiftKey) {
                // Shift + Click: Create new body (in world coordinates)
                isCreatingBody = true;
                const worldX = (mouseX - cameraX) / cameraZoom;
                const worldY = (mouseY - cameraY) / cameraZoom;
                creationStartX = worldX;
                creationStartY = worldY;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            } else if (e.ctrlKey || e.metaKey) {
                // Ctrl/Cmd + Drag: Pan camera
                isDraggingCamera = true;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                canvas.style.cursor = 'grabbing';
            } else {
                // Regular click: Select/drag body
                const worldX = (mouseX - cameraX) / cameraZoom;
                const worldY = (mouseY - cameraY) / cameraZoom;
                const bodyIndex = Module._findBodyAtPosition(worldX, worldY);
                if (bodyIndex >= 0) {
                    draggedBodyIndex = bodyIndex;
                    isDraggingBody = true;
                    selectedBodyIndex = bodyIndex;
                    canvas.style.cursor = 'move';
                    updateBodyInfo(bodyIndex);
                } else {
                    selectedBodyIndex = -1;
                    hideBodyInfo();
                }
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Store for creation indicator
            if (isCreatingBody) {
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }
            
            if (isDraggingCamera) {
                cameraX += mouseX - lastMouseX;
                cameraY += mouseY - lastMouseY;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            } else if (isDraggingBody && draggedBodyIndex >= 0) {
                // Transform mouse coordinates by camera
                const worldX = (mouseX - cameraX) / cameraZoom;
                const worldY = (mouseY - cameraY) / cameraZoom;
                Module._setBodyPosition(draggedBodyIndex, worldX, worldY);
                updateBodyInfo(draggedBodyIndex);
            } else {
                // Hover detection
                const worldX = (mouseX - cameraX) / cameraZoom;
                const worldY = (mouseY - cameraY) / cameraZoom;
                const bodyIndex = Module._findBodyAtPosition(worldX, worldY);
                canvas.style.cursor = bodyIndex >= 0 ? 'pointer' : 'default';
            }
        }
        
        function handleMouseUp(e) {
            if (isCreatingBody) {
                const rect = canvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                
                // Convert to world coordinates
                const worldEndX = (endX - cameraX) / cameraZoom;
                const worldEndY = (endY - cameraY) / cameraZoom;
                
                // Create new body
                const vx = (worldEndX - creationStartX) * 0.02;
                const vy = (worldEndY - creationStartY) * 0.02;
                
                // Random planet-like colors
                const colors = [
                    0x3498DBFF,  // Earth blue
                    0xE74C3CFF,  // Mars red
                    0xF39C12FF,  // Venus yellow
                    0x9B59B6FF,  // Neptune purple
                    0x1ABC9CFF,  // Uranus turquoise
                    0xE67E22FF,  // Jupiter orange
                    0xF4D03FFF,  // Saturn yellow
                    0xA2D5F2FF   // Ice world blue
                ];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                Module._addBody(creationStartX, creationStartY, vx, vy, 50.0, 10.0, color);
                const newestIndex = Module._getBodyCount() - 1;
                if (newestIndex >= 0) {
                    Module._setBodyCharge(newestIndex, newBodyCharge);
                }
                
                isCreatingBody = false;
            }
            
            if (isDraggingBody) {
                Module._saveState();
            }
            
            isDraggingBody = false;
            isDraggingCamera = false;
            draggedBodyIndex = -1;
            canvas.style.cursor = 'default';
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            cameraZoom *= zoomFactor;
            cameraZoom = Math.max(0.5, Math.min(cameraZoom, 3.0));
        }
        
        // Fun facts system
        const funFacts = [
            "The three-body problem has no general closed-form solution. Henri Poincar√© proved this in 1889!",
            "The Figure-8 orbit was discovered by Cris Moore in 1993 using a numerical search algorithm.",
            "Over 1000 periodic solutions to the three-body problem have been discovered since 2000!",
            "The Sun-Earth-Moon system is approximately a three-body problem (though Jupiter complicates things!).",
            "Chaotic systems like this are highly sensitive to initial conditions - change by 0.001% and everything changes!",
            "The three-body problem inspired the famous sci-fi novel by Liu Cixin.",
            "Lagrange points (L1-L5) are special solutions where a small body can maintain a stable position.",
            "Joseph-Louis Lagrange found the first exact solutions in 1772 - the L4 and L5 equilibrium points!",
            "The Pythagorean three-body problem (3:4:5 mass ratio) is named after the famous right triangle.",
            "Newton first studied the three-body problem trying to understand the Moon's motion!",
            "Symplectic integrators like Verlet preserve the geometric structure of physics better than standard methods.",
            "Binary star systems with planets are examples of real three-body systems in space!",
            "The energy drift you see is from numerical approximation - real physics conserves energy perfectly!",
            "Jupiter's Trojan asteroids sit at the L4 and L5 Lagrange points - natural three-body solutions!"
        ];
        
        let currentFactIndex = 0;
        
        function rotateFunFact() {
            currentFactIndex = (currentFactIndex + 1) % funFacts.length;
            const factElement = document.getElementById('funFactText');
            factElement.style.animation = 'fadeOut 0.2s ease';
            setTimeout(() => {
                factElement.textContent = funFacts[currentFactIndex];
                factElement.style.animation = 'fadeIn 0.3s ease';
            }, 200);
        }
        
        // Auto-rotate facts every 30 seconds
        setInterval(rotateFunFact, 30000);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                toggleSimulation();
            } else if (e.key === 'r' || e.key === 'R') {
                resetSimulation();
            } else if (e.key === 'Delete' && selectedBodyIndex >= 0) {
                Module._removeBody(selectedBodyIndex);
                selectedBodyIndex = -1;
                hideBodyInfo();
            } else if (e.key === 't' || e.key === 'T') {
                document.getElementById('trailCheck').click();
            } else if (e.key === 'v' || e.key === 'V') {
                document.getElementById('velocityCheck').click();
            } else if (e.key === 'f' || e.key === 'F') {
                rotateFunFact();
            }
        });
    </script>
</body>
</html>